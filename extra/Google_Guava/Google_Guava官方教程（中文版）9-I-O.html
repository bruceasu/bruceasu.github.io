<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://bruceasu.github.io/rss.xml"
      title="RSS feed for https://bruceasu.github.io/"/>
<title>Google_Guava官方教程（中文版）9-I/O</title>
<meta name="author" content="Bruce">
<meta name="referrer" content="no-referrer">
<link href= "/styles/org-manual.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="static/favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="/styles/font.css">
<link rel="stylesheet" media="screen and (min-width: 600px)" href="/styles/post.css">
<link rel="stylesheet" media="screen and (max-width: 600px)" href="/styles/post_mobile.css">
<link rel="stylesheet" media="screen and (min-width: 600px)" href="/styles/navigatebar.css">
<link rel="stylesheet" media="screen and (max-width: 600px)" href="/styles/navigatebar_mobile.css">
<link rel="stylesheet" href="/theme/highlight.css">

</head>
<body>
<div class="navigatebar">
    <div class="navigatebar-button navigatebar-mine">
        <a href="/index.html">Free World</a>
    </div>
    <div class="navigatebar-slogan">
        「生活可以更简单, 欢迎来到我的开源世界」
    </div>
    <div class="navigatebar-button">
        <a href="/index.html">Home</a>
    </div>
    <div class="navigatebar-button">
        <a href="/tags.html">Tags</a>
    </div>
    <div class="navigatebar-button">
        <a href="/rss.xml">Feeds</a>
    </div>
    <div class="navigatebar-button navigatebar-about">
        <a href="/about.html">About</a>
    </div>
</div>

      <div class="content-area">
<div class="title">Google_Guava官方教程（中文版）9-I/O</div>
<div class="category-area"><a href="https://bruceasu.github.io/tags.html#reprint"><div class="category">reprint</div></a> </div>
<div class="char-counter">2010-10-01</div>
        <div id="content">
<nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orge11fd64">字节流和字符流</a></li>
<li><a href="#org26b7a48">源与汇</a>
<ul>
<li><a href="#org3113140">创建源与汇</a></li>
<li><a href="#org0ab258a">使用源与汇</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<p>
I/O
</p>
<div id="outline-container-orge11fd64" class="outline-2">
<h2 id="orge11fd64">字节流和字符流</h2>
<div class="outline-text-2" id="text-orge11fd64">
<p>
Guava使用术语”流” 来表示可关闭的，并且在底层资源中有位置状态的I/O数据流。术语”字
节流”指的是InputStream或OutputStream，”字符流”指的是 Reader 或Writer（虽然他们的
接口Readable 和Appendable被更多地用于方法参数）。相应的工具方法分别在ByteStreams
和CharStreams中。大多数Guava流工具一次处理一个完整的流，并且/或者为了效率自己处
理缓冲。还要注意到，接受流为参数的Guava方法不会关闭这个流：关闭流的职责通常属于
打开流的代码块。其中的一些工具方法列举如下：
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">ByteStreams</td>
<td class="org-left">CharStreams</td>
</tr>

<tr>
<td class="org-left">byte[] toByteArray(InputStream)</td>
<td class="org-left">String toString(Readable)</td>
</tr>

<tr>
<td class="org-left">N/A</td>
<td class="org-left">List&lt;String&gt; readLines(Readable)</td>
</tr>

<tr>
<td class="org-left">long copy(InputStream, OutputStream)</td>
<td class="org-left">long copy(Readable, Appendable)</td>
</tr>

<tr>
<td class="org-left">void readFully(InputStream, byte[])</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">void skipFully(InputStream, long)</td>
<td class="org-left">void skipFully(Reader, long)</td>
</tr>

<tr>
<td class="org-left">OutputStream nullOutputStream()</td>
<td class="org-left">Writer nullWriter()</td>
</tr>
</tbody>
</table>

<p>
关于InputSupplier 和OutputSupplier要注意：
</p>

<p>
在ByteStreams、CharStreams以及com.google.common.io包中的一些其他类中，某些方法仍
然在使用 InputSupplier和OutputSupplier接口。这两个借口和相关的方法是不推荐使用的：
它们已经被下面描述的source和sink类 型取代了，并且最终会被移除。
</p>
</div>
</div>

<div id="outline-container-org26b7a48" class="outline-2">
<h2 id="org26b7a48">源与汇</h2>
<div class="outline-text-2" id="text-org26b7a48">
<p>
通常我们都会创建I/O工具方法，这样可以避免在做基础运算时总是直接和流打交道。例如，
Guava有 Files.toByteArray(File) 和Files.write(File, byte[])。然而，流工具方法的
创建经常最终导致散落各处的相似方法，每个方法读取不同类型的源或写入不同类型的汇
[sink]。例如，Guava中的Resources.toByteArray(URL)和Files.toByteArray(File)做了同
样的事情，只不过数据源一个是URL，一个是文件。为了解决这个问题，Guava有一系列关于
源与汇的抽象。源或汇指某个你知道如何从中打开流的资源，比如File或URL。源是可读的，
汇是可写的。此外，源与汇按照字节和字符划分类型。
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"> </td>
<td class="org-left">字节</td>
<td class="org-left">字符</td>
</tr>

<tr>
<td class="org-left">读</td>
<td class="org-left">ByteSource</td>
<td class="org-left">CharSource</td>
</tr>

<tr>
<td class="org-left">写</td>
<td class="org-left">ByteSink</td>
<td class="org-left">CharSink</td>
</tr>
</tbody>
</table>

<p>
源与汇API的好处是它们提供了通用的一组操作。比如，一旦你把数据源包装成了
ByteSource，无论它原先的类型是什么，你都得到了一组按字节操作的方法。
</p>
</div>

<div id="outline-container-org3113140" class="outline-3">
<h3 id="org3113140">创建源与汇</h3>
<div class="outline-text-3" id="text-org3113140">
<p>
Guava提供了若干源与汇的实现：
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">字节</th>
<th scope="col" class="org-left">字符</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Files.asByteSource(File)</td>
<td class="org-left">Files.asCharSource(File, Charset)</td>
</tr>

<tr>
<td class="org-left">Files.asByteSink(File, FileWriteMode&#x2026;)</td>
<td class="org-left">Files.asCharSink(File, Charset, FileWriteMode&#x2026;)</td>
</tr>

<tr>
<td class="org-left">Resources.asByteSource(URL)</td>
<td class="org-left">Resources.asCharSource(URL, Charset)</td>
</tr>

<tr>
<td class="org-left">ByteSource.wrap(byte[])</td>
<td class="org-left">CharSource.wrap(CharSequence)</td>
</tr>

<tr>
<td class="org-left">ByteSource.concat(ByteSource&#x2026;)</td>
<td class="org-left">CharSource.concat(CharSource&#x2026;)</td>
</tr>

<tr>
<td class="org-left">ByteSource.slice(long, long)</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">N/A</td>
<td class="org-left">ByteSource.asCharSource(Charset)</td>
</tr>

<tr>
<td class="org-left">N/A</td>
<td class="org-left">ByteSink.asCharSink(Charset)</td>
</tr>
</tbody>
</table>

<p>
此外，你也可以继承这些类，以创建新的实现。
</p>

<p>
注：把已经打开的流（比如InputStream）包装为源或汇听起来是很有诱惑力的，但是应该
避免这样做。源与汇的实现应该在每次 openStream()方法被调用时都创建一个新的流。始
终创建新的流可以让源或汇管理流的整个生命周期，并且让多次调用openStream()返回 的
流都是可用的。此外，如果你在创建源或汇之前创建了流，你不得不在异常的时候自己保证
关闭流，这压根就违背了发挥源与汇API优点的初衷。
</p>
</div>
</div>

<div id="outline-container-org0ab258a" class="outline-3">
<h3 id="org0ab258a">使用源与汇</h3>
<div class="outline-text-3" id="text-org0ab258a">
<p>
一旦有了源与汇的实例，就可以进行若干读写操作。
</p>

<ul class="org-ul">
<li>通用操作
所有源与汇都有一些方法用于打开新的流用于读或写。默认情况下，其他源与汇操作都是
先用这些方法打开流，然后做一些读或写，最后保证流被正确地关闭了。这些方法列举如
下：
<ul class="org-ul">
<li>openStream()：根据源与汇的类型，返回InputStream、OutputStream、Reader或者Writer。</li>
<li>openBufferedStream()：根据源与汇的类型，返回InputStream、OutputStream、BufferedReader或者BufferedWriter。返回的流保证在必要情况下做了缓冲。例如，从字节数组读数据的源就没有必要再在内存中作缓冲，这就是为什么该方法针对字节源不返回BufferedInputStream。字符源属于例外情况，它一定返回BufferedReader，因为BufferedReader中才有readLine()方法。</li>
</ul></li>

<li><p>
源操作
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">字节源</th>
<th scope="col" class="org-left">字符源</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">byte[]   read()</td>
<td class="org-left">String   read()</td>
</tr>

<tr>
<td class="org-left">N/A</td>
<td class="org-left">ImmutableList&lt;String&gt;   readLines()</td>
</tr>

<tr>
<td class="org-left">N/A</td>
<td class="org-left">String   readFirstLine()</td>
</tr>

<tr>
<td class="org-left">long   copyTo(ByteSink)</td>
<td class="org-left">long   copyTo(CharSink)</td>
</tr>

<tr>
<td class="org-left">long   copyTo(OutputStream)</td>
<td class="org-left">long   copyTo(Appendable)  </td>
</tr>

<tr>
<td class="org-left">long   size() (in bytes)</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">boolean   isEmpty()</td>
<td class="org-left">boolean   isEmpty()</td>
</tr>

<tr>
<td class="org-left">boolean   contentEquals(ByteSource)</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">HashCode   hash(HashFunction)</td>
<td class="org-left">N/A</td>
</tr>
</tbody>
</table></li>

<li><p>
汇操作
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">字节汇</th>
<th scope="col" class="org-left">字符汇</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">void write(byte[])</td>
<td class="org-left">void write(CharSequence)</td>
</tr>

<tr>
<td class="org-left">long writeFrom(InputStream)</td>
<td class="org-left">long writeFrom(Readable)</td>
</tr>

<tr>
<td class="org-left">N/A</td>
<td class="org-left">void writeLines(Iterable&lt;? extends CharSequence&gt;)</td>
</tr>

<tr>
<td class="org-left">N/A</td>
<td class="org-left">void writeLines(Iterable&lt;? extends CharSequence&gt;, String)</td>
</tr>
</tbody>
</table></li>
</ul>


<ul class="org-ul">
<li><p>
范例
</p>
<pre class="example">
 //Read the lines of a UTF-8 text file
 ImmutableList&lt;String&gt; lines = Files.asCharSource(file, Charsets.UTF_8).readLines();
 //Count distinct word occurrences in a file
 Multiset&lt;String&gt; wordOccurrences = HashMultiset.create(
        Splitter.on(CharMatcher.WHITESPACE)
            .trimResults()
            .omitEmptyStrings()
            .split(Files.asCharSource(file, Charsets.UTF_8).read()));
 //SHA-1 a file
 HashCode hash = Files.asByteSource(file).hash(Hashing.sha1());
 //Copy the data from a URL to a file
 Resources.asByteSource(url).copyTo(Files.asByteSink(file));
</pre></li>

<li><p>
文件操作
除了创建文件源和文件的方法，Files类还包含了若干你可能感兴趣的便利方法。
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">createParentDirs(File)</td>
<td class="org-left">必要时为文件创建父目录</td>
</tr>

<tr>
<td class="org-left">getFileExtension(String)</td>
<td class="org-left">返回给定路径所表示文件的扩展名</td>
</tr>

<tr>
<td class="org-left">getNameWithoutExtension(String)</td>
<td class="org-left">返回去除了扩展名的文件名</td>
</tr>

<tr>
<td class="org-left">simplifyPath(String)</td>
<td class="org-left">规范文件路径，并不总是与文件系统一致，请仔细测试</td>
</tr>

<tr>
<td class="org-left">fileTreeTraverser()</td>
<td class="org-left">返回TreeTraverser用于遍历文件树</td>
</tr>
</tbody>
</table></li>
</ul>
</div>
</div>
</div>

        </div>    </div>
    <div id="postamble" class="status"><div id="archive" style="padding-top: 3em; padding-bottom: 2em;"><a href="/archive.html">其它文章</a></div><script src="/js/av-min-1.5.0.js"></script>    </div>
</body>
</html>
