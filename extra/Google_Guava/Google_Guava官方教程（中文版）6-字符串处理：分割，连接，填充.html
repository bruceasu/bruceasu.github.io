<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://bruceasu.github.io/rss.xml"
      title="RSS feed for https://bruceasu.github.io/"/>
<title>Google_Guava官方教程（中文版）6-字符串处理：分割，连接，填充</title>
<meta name="author" content="Bruce">
<meta name="referrer" content="no-referrer">
<link href= "/styles/org-manual.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="static/favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="/styles/font.css">
<link rel="stylesheet" media="screen and (min-width: 600px)" href="/styles/post.css">
<link rel="stylesheet" media="screen and (max-width: 600px)" href="/styles/post_mobile.css">
<link rel="stylesheet" media="screen and (min-width: 600px)" href="/styles/navigatebar.css">
<link rel="stylesheet" media="screen and (max-width: 600px)" href="/styles/navigatebar_mobile.css">
<link rel="stylesheet" href="/theme/highlight.css">

</head>
<body>
<div class="navigatebar">
    <div class="navigatebar-button navigatebar-mine">
        <a href="/index.html">Free World</a>
    </div>
    <div class="navigatebar-slogan">
        「生活可以更简单, 欢迎来到我的开源世界」
    </div>
    <div class="navigatebar-button">
        <a href="/index.html">Home</a>
    </div>
    <div class="navigatebar-button">
        <a href="/tags.html">Tags</a>
    </div>
    <div class="navigatebar-button">
        <a href="/rss.xml">Feeds</a>
    </div>
    <div class="navigatebar-button navigatebar-about">
        <a href="/about.html">About</a>
    </div>
</div>

      <div class="content-area">
<div class="title">Google_Guava官方教程（中文版）6-字符串处理：分割，连接，填充</div>
<div class="category-area"><a href="https://bruceasu.github.io/tags.html#reprint"><div class="category">reprint</div></a> </div>
<div class="char-counter">2010-10-01</div>
        <div id="content">
<nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org942b43a">连接器[Joiner]</a></li>
<li><a href="#orgb156b04">拆分器[Splitter]</a>
<ul>
<li><a href="#org922130c">问题：”,a,,b,”.split(“,”)返回？</a></li>
<li><a href="#orgbd14334">拆分器工厂</a></li>
<li><a href="#org81a39ab">拆分器修饰符</a></li>
</ul>
</li>
<li><a href="#org64dabd7">字符匹配器[CharMatcher]</a>
<ul>
<li><a href="#org972e5ab">获取字符匹配器</a></li>
<li><a href="#orga62cf26">其他获取字符匹配器的常见方法包括：</a></li>
<li><a href="#org40612a5">使用字符匹配器</a></li>
</ul>
</li>
<li><a href="#org33a9a54">字符集[Charsets]</a></li>
<li><a href="#org7fcc4b8">大小写格式[CaseFormat]</a>
<ul>
<li><a href="#org971e90d">CaseFormat的用法很直接：</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<p>
字符串处理：分割，连接，填充
</p>

<div id="outline-container-org942b43a" class="outline-2">
<h2 id="org942b43a">连接器[Joiner]</h2>
<div class="outline-text-2" id="text-org942b43a">
<p>
用分隔符把字符串序列连接起来也可能会遇上不必要的麻烦。如果字符串序列中含有null，
那连接操作会更难。Fluent风格的Joiner让连接字符串更简单。
</p>
<pre class="example">
Joiner joiner = Joiner.on("; ").skipNulls();
return joiner.join("Harry", null, "Ron", "Hermione");

</pre>

<p>
上述代码返回”Harry; Ron; Hermione”。另外，useForNull(String)方法可以给定某个字符
串来替换null，而不像skipNulls()方法是直接忽略 null。 Joiner也可以用来连接对象类
型，在这种情况下，它会把对象的toString()值连接起来。
</p>

<pre class="example">
Joiner.on(",").join(Arrays.asList(1, 5, 7)); // returns "1,5,7"

</pre>

<p>
警告：joiner实例总是不可变的。用来定义joiner目标语义的配置方法总会返回一个新的
joiner实例。这使得joiner实例都是线程安全的，你可以将其定义为static final常量。
</p>
</div>
</div>

<div id="outline-container-orgb156b04" class="outline-2">
<h2 id="orgb156b04">拆分器[Splitter]</h2>
<div class="outline-text-2" id="text-orgb156b04">
<p>
JDK内建的字符串拆分工具有一些古怪的特性。比如，String.split悄悄丢弃了尾部的分隔
符。
</p>
</div>

<div id="outline-container-org922130c" class="outline-3">
<h3 id="org922130c">问题：”,a,,b,”.split(“,”)返回？</h3>
<div class="outline-text-3" id="text-org922130c">
<p class="verse">
1. “”, “a”, “”, “b”, “”<br>
2. null, “a”, null, “b”, null<br>
3. “a”, null, “b”<br>
4. “a”, “b”<br>
5. 以上都不对<br>
<br>
</p>

<p>
正确答案是5：””, “a”, “”, “b”。只有尾部的空字符串被忽略了。 Splitter使用令人放心
的、直白的流畅API模式对这些混乱的特性作了完全的掌控。
</p>
<pre class="example">
Splitter.on(',')
        .trimResults()
        .omitEmptyStrings()
        .split("foo,bar,,   qux");

</pre>

<p>
上述代码返回Iterable&lt;String&gt;，其中包含”foo”、”bar”和”qux”。Splitter可以被设置为
按照任何模式、字符、字符串或字符匹配器拆分。
</p>
</div>
</div>

<div id="outline-container-orgbd14334" class="outline-3">
<h3 id="orgbd14334">拆分器工厂</h3>
<div class="outline-text-3" id="text-orgbd14334">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法</th>
<th scope="col" class="org-left">描述</th>
<th scope="col" class="org-left">范例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Splitter.on(char)</td>
<td class="org-left">按单个字符拆分</td>
<td class="org-left">Splitter.on(‘;’)</td>
</tr>

<tr>
<td class="org-left">Splitter.on(CharMatcher)</td>
<td class="org-left">按字符匹配器拆分</td>
<td class="org-left">Splitter.on(CharMatcher.BREAKING<sub>WHITESPACE</sub>)</td>
</tr>

<tr>
<td class="org-left">Splitter.on(String)</td>
<td class="org-left">按字符串拆分</td>
<td class="org-left">Splitter.on(“,   “)</td>
</tr>

<tr>
<td class="org-left">Splitter.on(Pattern) Splitter.onPattern(String)</td>
<td class="org-left">按正则表达式拆分</td>
<td class="org-left">Splitter.onPattern(“\r?\n”)</td>
</tr>

<tr>
<td class="org-left">Splitter.fixedLength(int)</td>
<td class="org-left">按固定长度拆分；最后一段可能比给定长度短，但不会为空。</td>
<td class="org-left">Splitter.fixedLength(3)</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org81a39ab" class="outline-3">
<h3 id="org81a39ab">拆分器修饰符</h3>
<div class="outline-text-3" id="text-org81a39ab">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">omitEmptyStrings()</td>
<td class="org-left">从结果中自动忽略空字符串</td>
</tr>

<tr>
<td class="org-left">trimResults()</td>
<td class="org-left">移除结果字符串的前导空白和尾部空白</td>
</tr>

<tr>
<td class="org-left">trimResults(CharMatcher)</td>
<td class="org-left">给定匹配器，移除结果字符串的前导匹配字符和尾部匹配字符</td>
</tr>

<tr>
<td class="org-left">limit(int)</td>
<td class="org-left">限制拆分出的字符串数量</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>


<p>
如果你想要拆分器返回List，只要使用Lists.newArrayList(splitter.split(string))或类
似方法。 警告：splitter实例总是不可变的。用来定义splitter目标语义的配置方法总会
返回一个新的splitter实例。这使得splitter实例都是线程安全的，你可以将其定义为
static final常量。
</p>
</div>
</div>
</div>

<div id="outline-container-org64dabd7" class="outline-2">
<h2 id="org64dabd7">字符匹配器[CharMatcher]</h2>
<div class="outline-text-2" id="text-org64dabd7">
<p>
在以前的Guava版本中，StringUtil类疯狂地膨胀，其拥有很多处理字符串的方法：
allAscii、collapse、 collapseControlChars、collapseWhitespace、indexOfChars、
lastIndexNotOf、 numSharedChars、removeChars、removeCrLf、replaceChars、
retainAllChars、strip、 stripAndCollapse、stripNonDigits。 所有这些方法指向两个
概念上的问题：
</p>
<ol class="org-ol">
<li>怎么才算匹配字符？</li>
<li>如何处理这些匹配字符？</li>
</ol>
<p>
为了收拾这个泥潭，我们开发了CharMatcher。
</p>

<p>
直观上，你可以认为一个CharMatcher实例代表着某一类字符，如数字或空白字符。事实上
来说，CharMatcher实例就是对字符的布尔判断——CharMatcher确实也实现了
Predicate&lt;Character&gt;——但类似”所有空白字符”或”所有小写字母”的需求太普遍了，Guava
因此创建了这一API。
</p>

<p>
然而使用CharMatcher的好处更在于它提供了一系列方法，让你对字符作特定类型的操作：
修剪[trim]、折叠[collapse]、移除 [remove]、保留[retain]等等。CharMatcher实例首先
代表概念1：怎么才算匹配字符？然后它还提供了很多操作概念2：如何处理这 些匹配字符？
这样的设计使得API复杂度的线性增加可以带来灵活性和功能两方面的增长。
</p>
<pre class="example">
String noControl = CharMatcher.JAVA_ISO_CONTROL.removeFrom(string); //移除control字符
String theDigits = CharMatcher.DIGIT.retainFrom(string); //只保留数字字符
String spaced = CharMatcher.WHITESPACE.trimAndCollapseFrom(string, ' ');
//去除两端的空格，并把中间的连续空格替换成单个空格
String noDigits = CharMatcher.JAVA_DIGIT.replaceFrom(string, "*"); //用*号替换所有数字
String lowerAndDigit = CharMatcher.JAVA_DIGIT.or(CharMatcher.JAVA_LOWER_CASE).retainFrom(string);
// 只保留数字和小写字母

</pre>

<p>
注：CharMatcher只处理char类型代表的字符；它不能理解0x10000到0x10FFFF的Unicode 增
补字符。这些逻辑字符以代理对[surrogate pairs]的形式编码进字符串，而CharMatcher只
能将这种逻辑字符看待成两个独立的字符。
</p>
</div>

<div id="outline-container-org972e5ab" class="outline-3">
<h3 id="org972e5ab">获取字符匹配器</h3>
<div class="outline-text-3" id="text-org972e5ab">
<p>
CharMatcher中的常量可以满足大多数字符匹配需求：
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">ANY</td>
<td class="org-left">NONE</td>
<td class="org-left">WHITESPACE</td>
<td class="org-left">BREAKING<sub>WHITESPACE</sub></td>
</tr>

<tr>
<td class="org-left">INVISIBLE</td>
<td class="org-left">DIGIT</td>
<td class="org-left">JAVA<sub>LETTER</sub></td>
<td class="org-left">JAVA<sub>DIGIT</sub></td>
</tr>

<tr>
<td class="org-left">JAVA<sub>LETTER</sub><sub>OR</sub><sub>DIGIT</sub></td>
<td class="org-left">JAVA<sub>ISO</sub><sub>CONTROL</sub></td>
<td class="org-left">JAVA<sub>LOWER</sub><sub>CASE</sub></td>
<td class="org-left">JAVA<sub>UPPER</sub><sub>CASE</sub></td>
</tr>

<tr>
<td class="org-left">ASCII</td>
<td class="org-left">SINGLE<sub>WIDTH</sub></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orga62cf26" class="outline-3">
<h3 id="orga62cf26">其他获取字符匹配器的常见方法包括：</h3>
<div class="outline-text-3" id="text-orga62cf26">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">anyOf(CharSequence)</td>
<td class="org-left">枚举匹配字符。如CharMatcher.anyOf(“aeiou”)匹配小写英语元音</td>
</tr>

<tr>
<td class="org-left">is(char)</td>
<td class="org-left">给定单一字符匹配。</td>
</tr>

<tr>
<td class="org-left">inRange(char, char)</td>
<td class="org-left">给定字符范围匹配，如CharMatcher.inRange(‘a’, ‘z’)</td>
</tr>
</tbody>
</table>

<p>
此外，CharMatcher还有negate()、and(CharMatcher)和or(CharMatcher)方法。
</p>
</div>
</div>

<div id="outline-container-org40612a5" class="outline-3">
<h3 id="org40612a5">使用字符匹配器</h3>
<div class="outline-text-3" id="text-org40612a5">
<p>
CharMatcher提供了多种多样的方法操作CharSequence中的特定字符。其中最常用的罗列如
下：
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">collapseFrom(CharSequence,   char)</td>
<td class="org-left">把每组连续的匹配字符替换为特定字符。如WHITESPACE.collapseFrom(string, ‘ ‘)把字符串中的连续空白字符替换为单个空格。</td>
</tr>

<tr>
<td class="org-left">matchesAllOf(CharSequence)</td>
<td class="org-left">测试是否字符序列中的所有字符都匹配。</td>
</tr>

<tr>
<td class="org-left">removeFrom(CharSequence)</td>
<td class="org-left">从字符序列中移除所有匹配字符。</td>
</tr>

<tr>
<td class="org-left">retainFrom(CharSequence)</td>
<td class="org-left">在字符序列中保留匹配字符，移除其他字符。</td>
</tr>

<tr>
<td class="org-left">trimFrom(CharSequence)</td>
<td class="org-left">移除字符序列的前导匹配字符和尾部匹配字符。</td>
</tr>

<tr>
<td class="org-left">replaceFrom(CharSequence,   CharSequence)</td>
<td class="org-left">用特定字符序列替代匹配字符。</td>
</tr>
</tbody>
</table>

<p>
所有这些方法返回String，除了matchesAllOf返回的是boolean。
</p>
</div>
</div>
</div>

<div id="outline-container-org33a9a54" class="outline-2">
<h2 id="org33a9a54">字符集[Charsets]</h2>
<div class="outline-text-2" id="text-org33a9a54">
<p>
不要这样做字符集处理：
</p>
<pre class="example">
try {
    bytes = string.getBytes("UTF-8");
} catch (UnsupportedEncodingException e) {
    // how can this possibly happen?
    throw new AssertionError(e);
}

</pre>

<p>
试试这样写：
</p>
<pre class="example">
bytes = string.getBytes(Charsets.UTF_8);

</pre>

<p>
Charsets针对所有Java平台都要保证支持的六种字符集提供了常量引用。尝试使用这些常量，
而不是通过名称获取字符集实例。
</p>
</div>
</div>

<div id="outline-container-org7fcc4b8" class="outline-2">
<h2 id="org7fcc4b8">大小写格式[CaseFormat]</h2>
<div class="outline-text-2" id="text-org7fcc4b8">
<p>
CaseFormat被用来方便地在各种ASCII大小写规范间转换字符串——比如，编程语言的命名规
范。CaseFormat支持的格式如下：
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">格式</th>
<th scope="col" class="org-left">范例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">LOWER<sub>CAMEL</sub></td>
<td class="org-left">lowerCamel</td>
</tr>

<tr>
<td class="org-left">LOWER<sub>HYPHEN</sub></td>
<td class="org-left">lower-hyphen</td>
</tr>

<tr>
<td class="org-left">LOWER<sub>UNDERSCORE</sub></td>
<td class="org-left">lower<sub>underscore</sub></td>
</tr>

<tr>
<td class="org-left">UPPER<sub>CAMEL</sub></td>
<td class="org-left">UpperCamel</td>
</tr>

<tr>
<td class="org-left">UPPER<sub>UNDERSCORE</sub></td>
<td class="org-left">UPPER<sub>UNDERSCORE</sub></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-org971e90d" class="outline-3">
<h3 id="org971e90d">CaseFormat的用法很直接：</h3>
<div class="outline-text-3" id="text-org971e90d">
<pre class="example">
CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, "CONSTANT_NAME")); // returns "constantName"

</pre>

<p>
我们CaseFormat在某些时候尤其有用，比如编写代码生成器的时候。
</p>
</div>
</div>
</div>

        </div>    </div>
    <div id="postamble" class="status"><div id="archive" style="padding-top: 3em; padding-bottom: 2em;"><a href="/archive.html">其它文章</a></div><script src="/js/av-min-1.5.0.js"></script>    </div>
</body>
</html>
