<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://bruceasu.github.io/rss.xml"
      title="RSS feed for https://bruceasu.github.io/"/>
<title>Google_Guava官方教程（中文版）10-散列</title>
<meta name="author" content="Bruce">
<meta name="referrer" content="no-referrer">
<link href= "/styles/org-manual.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="static/favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="/styles/font.css">
<link rel="stylesheet" media="screen and (min-width: 600px)" href="/styles/post.css">
<link rel="stylesheet" media="screen and (max-width: 600px)" href="/styles/post_mobile.css">
<link rel="stylesheet" media="screen and (min-width: 600px)" href="/styles/navigatebar.css">
<link rel="stylesheet" media="screen and (max-width: 600px)" href="/styles/navigatebar_mobile.css">
<link rel="stylesheet" href="/theme/highlight.css">

</head>
<body>
<div class="navigatebar">
    <div class="navigatebar-button navigatebar-mine">
        <a href="/index.html">Free World</a>
    </div>
    <div class="navigatebar-slogan">
        「生活可以更简单, 欢迎来到我的开源世界」
    </div>
    <div class="navigatebar-button">
        <a href="/index.html">Home</a>
    </div>
    <div class="navigatebar-button">
        <a href="/tags.html">Tags</a>
    </div>
    <div class="navigatebar-button">
        <a href="/rss.xml">Feeds</a>
    </div>
    <div class="navigatebar-button navigatebar-about">
        <a href="/about.html">About</a>
    </div>
</div>

      <div class="content-area">
<div class="title">Google_Guava官方教程（中文版）10-散列</div>
<div class="category-area"><a href="https://bruceasu.github.io/tags.html#reprint"><div class="category">reprint</div></a> </div>
<div class="char-counter">2010-10-01</div>
        <div id="content">
<nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org8bd45b4">概述</a></li>
<li><a href="#orgda4c25a">散列包的组成</a>
<ul>
<li><a href="#orga12a5b4">HashFunction</a></li>
<li><a href="#org46705db">Hasher</a></li>
<li><a href="#org0e12e8f">Funnel</a></li>
<li><a href="#orgd8df377">HashCode</a></li>
</ul>
</li>
<li><a href="#org278f75a">布鲁姆过滤器[BloomFilter]</a></li>
<li><a href="#orgc95719a">Hashing类</a></li>
<li><a href="#orgae4cfa7">HashCode运算</a></li>
</ul>
</div>
</nav>
<p>
散列
</p>
<div id="outline-container-org8bd45b4" class="outline-2">
<h2 id="org8bd45b4">概述</h2>
<div class="outline-text-2" id="text-org8bd45b4">
<p>
Java内建的散列码[hash code]概念被限制为32位，并且没有分离散列算法和它们所作用的
数据，因此很难用备选算法进行替换。此外，使用Java内建方法实现的散列码通常是劣质的，
部分是因为它们最终都依赖于JDK类中已有的劣质散列码。Object.hashCode往往很快，但是
在预防碰撞上却很弱，也没有对分散性的预期。这使得它们很适合在散列表中运用，因为额
外碰撞只会带来 轻微的性能损失，同时差劲的分散性也可以容易地通过再散列来纠正
（Java中所有合理的散列表都用了再散列方法）。然而，在简单散列表以外的散列运用 中，
Object.hashCode几乎总是达不到要求——因此，有了com.google.common.hash包。
</p>
</div>
</div>

<div id="outline-container-orgda4c25a" class="outline-2">
<h2 id="orgda4c25a">散列包的组成</h2>
<div class="outline-text-2" id="text-orgda4c25a">
<p>
在这个包的Java doc中，我们可以看到很多不同的类，但是文档中没有明显地表明它们是怎
样 一起配合工作的。在介绍散列包中的类之前，让我们先来看下面这段代码范例：
</p>
<pre class="example">
HashFunction hf = Hashing.md5();
HashCode hc = hf.newHasher()
        .putLong(id)
        .putString(name, Charsets.UTF_8)
        .putObject(person, personFunnel)
        .hash();

</pre>
</div>

<div id="outline-container-orga12a5b4" class="outline-3">
<h3 id="orga12a5b4">HashFunction</h3>
<div class="outline-text-3" id="text-orga12a5b4">
<p>
HashFunction是一个单纯的（引用透明的）、无状态的方法，它把任意的数据块映射到固定
数目的位指，并且保证相同的输入一定产生相同的输出，不同的输入尽可能产生不同的输出。
</p>
</div>
</div>

<div id="outline-container-org46705db" class="outline-3">
<h3 id="org46705db">Hasher</h3>
<div class="outline-text-3" id="text-org46705db">
<p>
HashFunction的实例可以提供有状态的Hasher，Hasher提供了流畅的语法把数据添加到散列
运算，然后获取散列值。Hasher可以接受所有原生类型、字节数组、字节数组的片段、字符
序列、特定字符集的字符序列等等，或者任何给定了Funnel实现的对象。
</p>

<p>
Hasher实现了PrimitiveSink接口，这个接口为接受原生类型流的对象定义了fluent风格的
API
</p>
</div>
</div>

<div id="outline-container-org0e12e8f" class="outline-3">
<h3 id="org0e12e8f">Funnel</h3>
<div class="outline-text-3" id="text-org0e12e8f">
<p>
Funnel描述了如何把一个具体的对象类型分解为原生字段值，从而写入PrimitiveSink。比
如，如果我们有这样一个类：
</p>
<pre class="example">
class Person {
    final int id;
    final String firstName;
    final String lastName;
    final int birthYear;
}

</pre>

<p>
它对应的Funnel实现可能是：
</p>
<pre class="example">
Funnel&lt;Person&gt; personFunnel = new Funnel&lt;Person&gt;() {
    @Override
    public void funnel(Person person, PrimitiveSink into) {
        into.putInt(person.id)
            .putString(person.firstName, Charsets.UTF_8)
            .putString(person.lastName, Charsets.UTF_8)
            .putInt(birthYear);
    }
}
</pre>

<p>
注：putString(“abc”, Charsets.UTF<sub>8</sub>).putString(“def”, Charsets.UTF<sub>8</sub>)完全等同于
putString(“ab”, Charsets.UTF<sub>8</sub>).putString(“cdef”, Charsets.UTF<sub>8</sub>)，因为它们提供了
相同的字节序列。这可能带来预料之外的散列冲突。增加某种形式的分隔符有助于消除散列
冲突。
</p>
</div>
</div>

<div id="outline-container-orgd8df377" class="outline-3">
<h3 id="orgd8df377">HashCode</h3>
<div class="outline-text-3" id="text-orgd8df377">
<p>
一旦Hasher被赋予了所有输入，就可以通过hash()方法获取HashCode实例（多次调用hash()
方法的结果是不确定的）。HashCode可以通过asInt()、asLong()、asBytes()方法来做相等
性检测，此外，writeBytesTo(array, offset, maxLength)把散列值的前maxLength字节写
入字节数组。
</p>
</div>
</div>
</div>

<div id="outline-container-org278f75a" class="outline-2">
<h2 id="org278f75a">布鲁姆过滤器[BloomFilter]</h2>
<div class="outline-text-2" id="text-org278f75a">
<p>
布鲁姆过滤器是哈希运算的一项优雅运用，它可以简单地基于Object.hashCode()实现。简
而言之，布鲁姆过滤器是一种概率数据结构，它允许你检测某个对象是一定不在过滤器中，
还是可能已经添加到过滤器了。布鲁姆过滤器的维基页面对此作了全面的介绍，同时我们推
荐github中的一个教程。
</p>

<p>
Guava散列包有一个内建的布鲁姆过滤器实现，你只要提供Funnel就可以使用它。你可以使
用create(Funnel funnel, int expectedInsertions, double falsePositiveProbability)
方法获取BloomFilter&lt;T&gt;，缺省误检率[falsePositiveProbability]为3%。BloomFilter&lt;T&gt;
提供了boolean mightContain(T) 和void put(T)，它们的含义都不言自明了。
</p>
<pre class="example">
BloomFilter&lt;Person&gt; friends = BloomFilter.create(personFunnel, 500, 0.01);
for(Person friend : friendsList) {
    friends.put(friend);
}
// 很久以后
if (friends.mightContain(dude)) {
    //dude不是朋友还运行到这里的概率为1%
    //在这儿，我们可以在做进一步精确检查的同时触发一些异步加载
}
</pre>
</div>
</div>

<div id="outline-container-orgc95719a" class="outline-2">
<h2 id="orgc95719a">Hashing类</h2>
<div class="outline-text-2" id="text-orgc95719a">
<p>
Hashing类提供了若干散列函数，以及运算HashCode对象的工具方法。
</p>

<p>
已提供的散列函数
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">md5()</td>
<td class="org-left">murmur3<sub>128</sub>()</td>
<td class="org-left">murmur3<sub>32</sub>()</td>
<td class="org-left">sha1()</td>
</tr>

<tr>
<td class="org-left">sha256()</td>
<td class="org-left">sha512()</td>
<td class="org-left">goodFastHash(int bits)</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-orgae4cfa7" class="outline-2">
<h2 id="orgae4cfa7">HashCode运算</h2>
<div class="outline-text-2" id="text-orgae4cfa7">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">HashCode combineOrdered( Iterable&lt;HashCode&gt;)</td>
<td class="org-left">以有序方式联接散列码，如果两个散列集合用该方法联接出的散列码相同，那么散列集合的元素可能是顺序相等的</td>
</tr>

<tr>
<td class="org-left">HashCode   combineUnordered( Iterable&lt;HashCode&gt;)</td>
<td class="org-left">以无序方式联接散列码，如果两个散列集合用该方法联接出的散列码相同，那么散列集合的元素可能在某种排序下是相等的</td>
</tr>

<tr>
<td class="org-left">int   consistentHash( HashCode, int buckets)</td>
<td class="org-left">为给定的”桶”大小返回一致性哈希值。当”桶”增长时，该方法保证最小程度的一致性哈希值变化。详见一致性哈希。</td>
</tr>
</tbody>
</table>
</div>
</div>

        </div>    </div>
    <div id="postamble" class="status"><div id="archive" style="padding-top: 3em; padding-bottom: 2em;"><a href="/archive.html">其它文章</a></div><script src="/js/av-min-1.5.0.js"></script>    </div>
</body>
</html>
