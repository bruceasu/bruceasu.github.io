<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://bruceasu.github.io/rss.xml"
      title="RSS feed for https://bruceasu.github.io/"/>
<title>Google_Guava官方教程（中文版）8-区间</title>
<meta name="author" content="Bruce">
<meta name="referrer" content="no-referrer">
<link href= "/styles/org-manual.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="static/favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="/styles/font.css">
<link rel="stylesheet" media="screen and (min-width: 600px)" href="/styles/post.css">
<link rel="stylesheet" media="screen and (max-width: 600px)" href="/styles/post_mobile.css">
<link rel="stylesheet" media="screen and (min-width: 600px)" href="/styles/navigatebar.css">
<link rel="stylesheet" media="screen and (max-width: 600px)" href="/styles/navigatebar_mobile.css">
<link rel="stylesheet" href="/theme/highlight.css">

</head>
<body>
<div class="navigatebar">
    <div class="navigatebar-button navigatebar-mine">
        <a href="/index.html">Free World</a>
    </div>
    <div class="navigatebar-slogan">
        「生活可以更简单, 欢迎来到我的开源世界」
    </div>
    <div class="navigatebar-button">
        <a href="/index.html">Home</a>
    </div>
    <div class="navigatebar-button">
        <a href="/tags.html">Tags</a>
    </div>
    <div class="navigatebar-button">
        <a href="/rss.xml">Feeds</a>
    </div>
    <div class="navigatebar-button navigatebar-about">
        <a href="/about.html">About</a>
    </div>
</div>

      <div class="content-area">
<div class="title">Google_Guava官方教程（中文版）8-区间</div>
<div class="category-area"><a href="https://bruceasu.github.io/tags.html#reprint"><div class="category">reprint</div></a> </div>
<div class="char-counter">2010-10-01</div>
        <div id="content">
<nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgd070862">范例</a></li>
<li><a href="#org03187d6">简介</a></li>
<li><a href="#org8fc25f3">构建区间</a></li>
<li><a href="#orgb4ebd13">区间运算</a></li>
<li><a href="#org4eae163">查询运算</a></li>
<li><a href="#org5099433">关系运算</a>
<ul>
<li><a href="#org34d7640">包含[enclose]</a></li>
<li><a href="#org183e36f">相连[isConnected]</a></li>
<li><a href="#org6a22438">交集[intersection]</a></li>
<li><a href="#org4a3bcd6">跨区间[span]</a></li>
</ul>
</li>
<li><a href="#org4b9ff32">离散域</a></li>
<li><a href="#org77ea1c6">你自己的离散域</a></li>
</ul>
</div>
</nav>
<p>
区间
</p>
<div id="outline-container-orgd070862" class="outline-2">
<h2 id="orgd070862">范例</h2>
<div class="outline-text-2" id="text-orgd070862">
<pre class="example">
List scores;
Iterable belowMedian =Iterables.filter(scores,Range.lessThan(median));
...
Range validGrades = Range.closed(1, 12);
for(int grade : ContiguousSet.create(validGrades, DiscreteDomain.integers())) {
    ...
}
</pre>
</div>
</div>

<div id="outline-container-org03187d6" class="outline-2">
<h2 id="org03187d6">简介</h2>
<div class="outline-text-2" id="text-org03187d6">
<p>
区间，有时也称为范围，是特定域中的凸性（非正式说法为连续的或不中断的）部分。在形
式上，凸性表示对a&lt;=b&lt;=c, range.contains(a)且range.contains(c)意味着
range.contains(b)。
</p>

<p>
区间可以延伸至无限——例如，范围”x&gt;3″包括任意大于3的值——也可以被限制为有限，如”
2&lt;=x&lt;5″。Guava用更紧凑的方法表示范围，有数学背景的程序员对此是耳熟能详的：
</p>
<ul class="org-ul">
<li>(a..b) = {x | a &lt; x &lt; b}</li>
<li>[a..b] = {x | a &lt;= x &lt;= b}</li>
<li>[a..b) = {x | a &lt;= x &lt; b}</li>
<li>(a..b] = {x | a &lt; x &lt;= b}</li>
<li>(a..+∞) = {x | x &gt; a}</li>
<li>[a..+∞) = {x | x &gt;= a}</li>
<li>(-∞..b) = {x | x &lt; b}</li>
<li>(-∞..b] = {x | x &lt;= b}</li>
<li>(-∞..+∞) = 所有值</li>
</ul>

<p>
上面的a、b称为端点 。为了提高一致性，Guava中的Range要求上端点不能小于下端点。上
下端点有可能是相等的，但要求区间是闭区间或半开半闭区间（至少有一个端点是包含在区
间中的）：
</p>
<ul class="org-ul">
<li>[a..a]：单元素区间</li>
<li>[a..a); (a..a]：空区间，但它们是有效的</li>
<li>(a..a)：无效区间</li>
</ul>

<p>
Guava用类型Range&lt;C&gt;表示区间。所有区间实现都是不可变类型。
</p>
</div>
</div>

<div id="outline-container-org8fc25f3" class="outline-2">
<h2 id="org8fc25f3">构建区间</h2>
<div class="outline-text-2" id="text-org8fc25f3">
<p>
区间实例可以由Range类的静态方法获取：
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">(a..b)</td>
<td class="org-left">open(C, C)</td>
</tr>

<tr>
<td class="org-left">[a..b]</td>
<td class="org-left">closed(C, C)</td>
</tr>

<tr>
<td class="org-left">[a..b)</td>
<td class="org-left">closedOpen(C, C)</td>
</tr>

<tr>
<td class="org-left">(a..b]</td>
<td class="org-left">openClosed(C, C)</td>
</tr>

<tr>
<td class="org-left">(a..+∞)</td>
<td class="org-left">greaterThan(C)</td>
</tr>

<tr>
<td class="org-left">[a..+∞)</td>
<td class="org-left">atLeast(C)</td>
</tr>

<tr>
<td class="org-left">(-∞..b)</td>
<td class="org-left">lessThan(C)</td>
</tr>

<tr>
<td class="org-left">(-∞..b]</td>
<td class="org-left">atMost(C)</td>
</tr>

<tr>
<td class="org-left">(-∞..+∞)</td>
<td class="org-left">all()</td>
</tr>
</tbody>
</table>

<pre class="example">
Range.closed("left", "right"); //字典序在"left"和"right"之间的字符串，闭区间
Range.lessThan(4.0); //严格小于4.0的double值
</pre>

<p>
此外，也可以明确地指定边界类型来构造区间：
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">有界区间</td>
<td class="org-left">range(C, BoundType, C,   BoundType)</td>
</tr>

<tr>
<td class="org-left">无上界区间：((a..+∞) 或[a..+∞))</td>
<td class="org-left">downTo(C, BoundType)</td>
</tr>

<tr>
<td class="org-left">无下界区间：((-∞..b) 或(-∞..b])</td>
<td class="org-left">upTo(C, BoundType)</td>
</tr>
</tbody>
</table>

<p>
这里的BoundType是一个枚举类型，包含CLOSED和OPEN两个值。
</p>
<pre class="example">
Range.downTo(4, boundType);// (a..+∞)或[a..+∞)，取决于boundType
Range.range(1, CLOSED, 4, OPEN);// [1..4)，等同于Range.closedOpen(1, 4)
</pre>
</div>
</div>

<div id="outline-container-orgb4ebd13" class="outline-2">
<h2 id="orgb4ebd13">区间运算</h2>
<div class="outline-text-2" id="text-orgb4ebd13">
<p>
Range的基本运算是它的contains(C) 方法，和你期望的一样，它用来区间判断是否包含某
个值。此外，Range实例也可以当作Predicate，并且在函数式编程中使用（译者注：见第4
章）。任何Range实例也都支持containsAll(Iterable&lt;? extends C&gt;)方法：
</p>
<pre class="example">
Range.closed(1, 3).contains(2);//return true
Range.closed(1, 3).contains(4);//return false
Range.lessThan(5).contains(5); //return false
Range.closed(1, 4).containsAll(Ints.asList(1, 2, 3)); //return true
</pre>
</div>
</div>

<div id="outline-container-org4eae163" class="outline-2">
<h2 id="org4eae163">查询运算</h2>
<div class="outline-text-2" id="text-org4eae163">
<p>
Range类提供了以下方法来 查看区间的端点：
</p>
<ul class="org-ul">
<li>hasLowerBound()和hasUpperBound()：判断区间是否有特定边界，或是无限的；</li>
<li>lowerBoundType()和upperBoundType()：返回区间边界类型，CLOSED或OPEN；如果区间没
有对应的边界，抛出IllegalStateException；</li>
<li>lowerEndpoint()和upperEndpoint()：返回区间的端点值；如果区间没有对应的边界，抛
出IllegalStateException；</li>
<li>isEmpty()：判断是否为空区间。</li>
</ul>

<pre class="example">
Range.closedOpen(4, 4).isEmpty(); // returns true
Range.openClosed(4, 4).isEmpty(); // returns true
Range.closed(4, 4).isEmpty(); // returns false
Range.open(4, 4).isEmpty(); // Range.open throws IllegalArgumentException
Range.closed(3, 10).lowerEndpoint(); // returns 3
Range.open(3, 10).lowerEndpoint(); // returns 3
Range.closed(3, 10).lowerBoundType(); // returns CLOSED
Range.open(3, 10).upperBoundType(); // returns OPEN

</pre>
</div>
</div>

<div id="outline-container-org5099433" class="outline-2">
<h2 id="org5099433">关系运算</h2>
<div class="outline-text-2" id="text-org5099433">
</div>
<div id="outline-container-org34d7640" class="outline-3">
<h3 id="org34d7640">包含[enclose]</h3>
<div class="outline-text-3" id="text-org34d7640">
<p>
区间之间的最基本关系就是包含[encloses(Range)]：如果内区间的边界没有超出外区间的
边界，则外区间包含内区间。包含判断的结果完全取决于区间端点的比较！
</p>
<ul class="org-ul">
<li>[3..6] 包含[4..5] ；</li>
<li>(3..6) 包含(3..6) ；</li>
<li>[3..6] 包含[4..4)，虽然后者是空区间；</li>
<li>(3..6]不 包含[3..6] ；</li>
<li>[4..5]不 包含(3..6)，虽然前者包含了后者的所有值，离散域[discrete domains]可以
解决这个问题（见8.5节）；</li>
<li>[3..6]不 包含(1..1]，虽然前者包含了后者的所有值。</li>
</ul>

<p>
包含是一种偏序关系[partial ordering]。基于包含关系的概念，Range还提供了以下运算方法。
</p>
</div>
</div>

<div id="outline-container-org183e36f" class="outline-3">
<h3 id="org183e36f">相连[isConnected]</h3>
<div class="outline-text-3" id="text-org183e36f">
<p>
Range.isConnected(Range)判断区间是否是相连的。具体来说，isConnected测试是否有区
间同时包含于这两个区间，这等同于数学上的定义”两个区间的并集是连续集合的形式”（空
区间的特殊情况除外）。相连是一种自反的[reflexive]、对称的[symmetric]关系。
</p>
<pre class="example">
Range.closed(3, 5).isConnected(Range.open(5, 10)); // returns true
Range.closed(0, 9).isConnected(Range.closed(3, 4)); // returns true
Range.closed(0, 5).isConnected(Range.closed(3, 9)); // returns true
Range.open(3, 5).isConnected(Range.open(5, 10)); // returns false
Range.closed(1, 5).isConnected(Range.closed(6, 10)); // returns false
</pre>
</div>
</div>

<div id="outline-container-org6a22438" class="outline-3">
<h3 id="org6a22438">交集[intersection]</h3>
<div class="outline-text-3" id="text-org6a22438">
<p>
Range.intersection(Range)返回两个区间的交集：既包含于第一个区间，又包含于另一个
区间的最大区间。当且仅当两个区间是相连的，它们才有交集。如果两个区间没有交集，该
方法将抛出IllegalArgumentException。交集是可互换的[commutative] 、关联的
[associative] 运算[operation]。
</p>
<pre class="example">
Range.closed(3, 5).intersection(Range.open(5, 10)); // returns (5, 5]
Range.closed(0, 9).intersection(Range.closed(3, 4)); // returns [3, 4]
Range.closed(0, 5).intersection(Range.closed(3, 9)); // returns [3, 5]
Range.open(3, 5).intersection(Range.open(5, 10)); // throws IAE
Range.closed(1, 5).intersection(Range.closed(6, 10)); // throws IAE
</pre>
</div>
</div>

<div id="outline-container-org4a3bcd6" class="outline-3">
<h3 id="org4a3bcd6">跨区间[span]</h3>
<div class="outline-text-3" id="text-org4a3bcd6">
<p>
Range.span(Range)返回”同时包括两个区间的最小区间”，如果两个区间相连，那就是它们
的并集。span是可互换的[commutative] 、关联的[associative] 、闭合的[closed]运算
[operation]。
</p>
<pre class="example">
Range.closed(3, 5).span(Range.open(5, 10)); // returns [3, 10)
Range.closed(0, 9).span(Range.closed(3, 4)); // returns [0, 9]
Range.closed(0, 5).span(Range.closed(3, 9)); // returns [0, 9]
Range.open(3, 5).span(Range.open(5, 10)); // returns (3, 10)
Range.closed(1, 5).span(Range.closed(6, 10)); // returns [1, 10]
</pre>
</div>
</div>
</div>

<div id="outline-container-org4b9ff32" class="outline-2">
<h2 id="org4b9ff32">离散域</h2>
<div class="outline-text-2" id="text-org4b9ff32">
<p>
部分（但不是全部）可比较类型是离散的，即区间的上下边界都是可枚举的。
</p>

<p>
在Guava中，用DiscreteDomain&lt;C&gt;实现类型C的离散形式操作。一个离散域总是代表某种类
型值的全集；它不能代表类似”素数”、”长度为5的字符串”或”午夜的时间戳”这样的局部域。
</p>

<p>
DiscreteDomain提供的离散域实例包括：
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">类型</td>
<td class="org-left">离散域</td>
</tr>

<tr>
<td class="org-left">Integer</td>
<td class="org-left">integers()</td>
</tr>

<tr>
<td class="org-left">Long</td>
<td class="org-left">longs()</td>
</tr>
</tbody>
</table>

<p>
一旦获取了DiscreteDomain实例，你就可以使用下面的Range运算方法：
</p>
<ul class="org-ul">
<li>ContiguousSet.create(range, domain)：用ImmutableSortedSet&lt;C&gt;形式表示Range&lt;C&gt;中
符合离散域定义的元素，并增加一些额外操作——译者注：实际返回ImmutableSortedSet的
子类ContiguousSet。（对无限区间不起作用，除非类型C本身是有限的，比如int就是可
枚举的）</li>
<li>canonical(domain)：把离散域转为区间的”规范形式”。如果ContiguousSet.create(a,
domain).equals(ContiguousSet.create(b, domain))并且!a.isEmpty()，则有
a.canonical(domain).equals(b.canonical(domain))。（这并不意味着a.equals(b)）</li>
</ul>

<pre class="example">
ImmutableSortedSet set = ContigousSet.create(Range.open(1, 5), iscreteDomain.integers());
//set包含[2, 3, 4]
ContiguousSet.create(Range.greaterThan(0), DiscreteDomain.integers());
//set包含[1, 2, ..., Integer.MAX_VALUE]
</pre>

<p>
注意，ContiguousSet.create并没有真的构造了整个集合，而是返回了set形式的区间视图。
</p>
</div>
</div>

<div id="outline-container-org77ea1c6" class="outline-2">
<h2 id="org77ea1c6">你自己的离散域</h2>
<div class="outline-text-2" id="text-org77ea1c6">
<p>
你可以创建自己的离散域，但必须记住DiscreteDomain契约的几个重要方面。
</p>
<ul class="org-ul">
<li>一个离散域总是代表某种类型值的全集；它不能代表类似”素数”或”长度为5的字符串”这
样的局部域。所以举例来说，你无法构造一个DiscreteDomain以表示精确到秒的JODA
DateTime日期集合：因为那将无法包含JODA DateTime的所有值。</li>
<li>DiscreteDomain可能是无限的——比如BigInteger DiscreteDomain。这种情况下，你应当
用minValue()和maxValue()的默认实现，它们会抛出NoSuchElementException。但Guava
禁止把无限区间传入ContiguousSet.create——译者注：那明显得不到一个可枚举的集合。</li>
</ul>

<p>
如果我需要一个Comparator呢？
</p>

<p>
我们想要在Range的可用性与API复杂性之间找到特定的平衡，这部分导致了我们没有提供基
于Comparator的接口：我们不需要操心区间是怎样基于不同Comparator互动的；所有API签
名都是简单明确的；这样更好。另一方面，如果你需要任意Comparator，可以按下列其中一
项来做：
</p>
<ul class="org-ul">
<li>使用通用的Predicate接口，而不是Range类。（Range实现了Predicate接口，因此可以用
Predicates.compose(range, function)获取Predicate实例）</li>
<li>使用包装类以定义期望的排序。</li>
</ul>

<p>
译者注：实际上Range规定元素类型必须是Comparable，这已经满足了大多数需求。如果需
要自定义特殊的比较逻辑，可以用Predicates.compose(range, function)组合比较的
function。
</p>
</div>
</div>

        </div>    </div>
    <div id="postamble" class="status"><div id="archive" style="padding-top: 3em; padding-bottom: 2em;"><a href="/archive.html">其它文章</a></div><script src="/js/av-min-1.5.0.js"></script>    </div>
</body>
</html>
