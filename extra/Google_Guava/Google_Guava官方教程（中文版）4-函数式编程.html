<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://bruceasu.github.io/rss.xml"
      title="RSS feed for https://bruceasu.github.io/"/>
<title>Google_Guava官方教程（中文版）4-函数式编程</title>
<meta name="author" content="Bruce">
<meta name="referrer" content="no-referrer">
<link href= "/styles/org-manual.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="static/favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="/styles/font.css">
<link rel="stylesheet" media="screen and (min-width: 600px)" href="/styles/post.css">
<link rel="stylesheet" media="screen and (max-width: 600px)" href="/styles/post_mobile.css">
<link rel="stylesheet" media="screen and (min-width: 600px)" href="/styles/navigatebar.css">
<link rel="stylesheet" media="screen and (max-width: 600px)" href="/styles/navigatebar_mobile.css">
<link rel="stylesheet" href="/theme/highlight.css">

</head>
<body>
<div class="navigatebar">
    <div class="navigatebar-button navigatebar-mine">
        <a href="/index.html">Free World</a>
    </div>
    <div class="navigatebar-slogan">
        「生活可以更简单, 欢迎来到我的开源世界」
    </div>
    <div class="navigatebar-button">
        <a href="/index.html">Home</a>
    </div>
    <div class="navigatebar-button">
        <a href="/tags.html">Tags</a>
    </div>
    <div class="navigatebar-button">
        <a href="/rss.xml">Feeds</a>
    </div>
    <div class="navigatebar-button navigatebar-about">
        <a href="/about.html">About</a>
    </div>
</div>

      <div class="content-area">
<div class="title">Google_Guava官方教程（中文版）4-函数式编程</div>
<div class="category-area"><a href="https://bruceasu.github.io/tags.html#reprint"><div class="category">reprint</div></a> </div>
<div class="char-counter">2010-10-01</div>
        <div id="content">
<nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org382b86e">注意事项</a></li>
<li><a href="#orgc3f3c87">Functions[函数]和Predicates[断言]</a>
<ul>
<li><a href="#org69c7cb4">特殊的断言</a></li>
<li><a href="#org8443c94">操作Functions和Predicates</a></li>
<li><a href="#org0d17f84">使用函数式编程</a></li>
<li><a href="#org299df95">断言</a></li>
<li><a href="#orga719815">函数</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<p>
函数式编程
</p>

<div id="outline-container-org382b86e" class="outline-2">
<h2 id="org382b86e">注意事项</h2>
<div class="outline-text-2" id="text-org382b86e">
<p>
截至JDK7，Java中也只能通过笨拙冗长的匿名类来达到近似函数式编程的效果。预计JDK8中
会有所改变，但Guava现在就想给JDK5以上用户提供这类支持。
</p>

<p>
过度使用Guava函数式编程会导致冗长、混乱、可读性差而且低效的代码。这是迄今为止最
容易（也是最经常）被滥用的部分，如果你想通过函数式风格达成一行代码，致使这行代码
长到荒唐，Guava团队会泪流满面。
</p>

<p>
比较如下代码：
</p>
<pre class="example">
Function&lt;String, Integer&gt; lengthFunction = new Function&lt;String, Integer&gt;() {
    public Integer apply(String string) {
        return string.length();
    }
};
Predicate&lt;String&gt; allCaps = new Predicate&lt;String&gt;() {
    public boolean apply(String string) {
        return CharMatcher.JAVA_UPPER_CASE.matchesAllOf(string);
    }
};

Multiset&lt;Integer&gt; lengths = HashMultiset.create(
      Iterables.transform(Iterables.filter(strings, allCaps), lengthFunction));

// 或FluentIterable的版本
Multiset&lt;Integer&gt; lengths = HashMultiset.create(
    FluentIterable.from(strings)
        .filter(new Predicate&lt;String&gt;() {
            public boolean apply(String string) {
                return CharMatcher.JAVA_UPPER_CASE.matchesAllOf(string);
             }
        })
        .transform(new Function&lt;String, Integer&gt;() {
            public Integer apply(String string) {
                return string.length();
            }
        }));

// 还有
Multiset&lt;Integer&gt; lengths = HashMultiset.create();
 for (String string : strings) {
     if (CharMatcher.JAVA_UPPER_CASE.matchesAllOf(string)) {
         lengths.add(string.length());
     }
 }

</pre>

<p>
即使用了静态导入，甚至把Function和Predicate的声明放到别的文件，第一种代码实现仍
然不简洁，可读性差并且效率较低。
</p>

<p>
截至JDK7，命令式代码仍应是默认和第一选择。不应该随便使用函数式风格，除非你绝对确
定以下两点之一：
</p>
<ul class="org-ul">
<li>使用函数式风格以后，整个工程的代码行会净减少。在上面的例子中，函数式版本用了11
行， 命令式代码用了6行，把函数的定义放到另一个文件或常量中，并不能帮助减少总代
码行。</li>
<li>为了提高效率，转换集合的结果需要懒视图，而不是明确计算过的集合。此外，确保你已
经阅读和重读了Effective Java的第55条，并且除了阅读本章后面的说明，你还真正做了
性能测试并且有测试数据来证明函数式版本更快。</li>
</ul>

<p>
请务必确保，当使用Guava函数式的时候，用传统的命令式做同样的事情不会更具可读性。
尝试把代码写下来，看看它是不是真的那么糟糕？会不会比你想尝试的极其笨拙的函数式
更具可读性。
</p>
</div>
</div>

<div id="outline-container-orgc3f3c87" class="outline-2">
<h2 id="orgc3f3c87">Functions[函数]和Predicates[断言]</h2>
<div class="outline-text-2" id="text-orgc3f3c87">
<p>
本节只讨论直接与Function和Predicate打交道的Guava功能。一些其他工具类也和”函数式
风格”相关，例如Iterables.concat(Iterable&lt;Iterable&gt;)，和其他用常量时间返回视图的
方法。尝试看看2.3节的集合工具类。
</p>

<p>
Guava提供两个基本的函数式接口：
</p>
<ul class="org-ul">
<li>Function&lt;A, B&gt;，它声明了单个方法B apply(A input)。Function对象通常被预期为引用
透明的——没有副作用——并且引用透明性中的”相等”语义与equals一致，如a.equals(b)意
味着function.apply(a).equals(function.apply(b))。</li>
<li>Predicate&lt;T&gt;，它声明了单个方法boolean apply(T input)。Predicate对象通常也被预
期为无副作用函数，并且”相等”语义与equals一致。</li>
</ul>
</div>

<div id="outline-container-org69c7cb4" class="outline-3">
<h3 id="org69c7cb4">特殊的断言</h3>
<div class="outline-text-3" id="text-org69c7cb4">
<p>
字符类型有自己特定版本的Predicate——CharMatcher，它通常更高效，并且在某些需求方面
更有用。CharMatcher实现了Predicate&lt;Character&gt;，可以当作Predicate一样使用，要把
Predicate转成CharMatcher，可以使用CharMatcher.forPredicate。更多细节请参考第6章-
字符串处理。
</p>

<p>
此外，对可比较类型和基于比较逻辑的Predicate，Range类可以满足大多数需求——它表示一
个不可变区间。Range类实现了 Predicate，用以判断值是否在区间内。例如，
Range.atMost(2)就是个完全合法的 Predicate&lt;Integer&gt;。更多使用Range的细节请参照第8
章。
</p>
</div>
</div>

<div id="outline-container-org8443c94" class="outline-3">
<h3 id="org8443c94">操作Functions和Predicates</h3>
<div class="outline-text-3" id="text-org8443c94">
<p>
Functions提供简便的Function构造和操作方法，包括：
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">forMap(Map&lt;A, B&gt;)</td>
<td class="org-left">compose(Function&lt;B, C&gt;, Function&lt;A, B&gt;)</td>
<td class="org-left">constant(T)</td>
</tr>

<tr>
<td class="org-left">identity()</td>
<td class="org-left">toStringFunction()</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
细节请参考Javadoc。
相应地，Predicates提供了更多构造和处理Predicate的方法，下面是一些例子：
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">instanceOf(Class)</td>
<td class="org-left">assignableFrom(Class)</td>
<td class="org-left">contains(Pattern)</td>
</tr>

<tr>
<td class="org-left">in(Collection)</td>
<td class="org-left">isNull()</td>
<td class="org-left">alwaysFalse()</td>
</tr>

<tr>
<td class="org-left">alwaysTrue()</td>
<td class="org-left">equalTo(Object)</td>
<td class="org-left">compose(Predicate, Function)</td>
</tr>

<tr>
<td class="org-left">and(Predicate&#x2026;)</td>
<td class="org-left">or(Predicate&#x2026;)</td>
<td class="org-left">not(Predicate)</td>
</tr>
</tbody>
</table>
<p>
细节请参考Javadoc。
</p>
</div>
</div>

<div id="outline-container-org0d17f84" class="outline-3">
<h3 id="org0d17f84">使用函数式编程</h3>
<div class="outline-text-3" id="text-org0d17f84">
<p>
Guava提供了很多工具方法，以便用Function或Predicate操作集合。这些方法通常可以在集
合工具类找到，如Iterables，Lists，Sets，Maps，Multimaps等。
</p>
</div>
</div>

<div id="outline-container-org299df95" class="outline-3">
<h3 id="org299df95">断言</h3>
<div class="outline-text-3" id="text-org299df95">
<p>
断言的最基本应用就是过滤集合。所有Guava过滤方法都返回”视图”——译者注：即并非用一
个新的集合表示过滤，而只是基于原集合的视图。
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">集合类型</th>
<th scope="col" class="org-left">过滤方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Iterable</td>
<td class="org-left">Iterables.filter(Iterable, Predicate)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">FluentIterable.filter(Predicate)</td>
</tr>

<tr>
<td class="org-left">Iterator</td>
<td class="org-left">Iterators.filter(Iterator, Predicate)</td>
</tr>

<tr>
<td class="org-left">Collection</td>
<td class="org-left">Collections2.filter(Collection, Predicate)</td>
</tr>

<tr>
<td class="org-left">Set</td>
<td class="org-left">Sets.filter(Set, Predicate)</td>
</tr>

<tr>
<td class="org-left">SortedSet</td>
<td class="org-left">Sets.filter(SortedSet, Predicate)</td>
</tr>

<tr>
<td class="org-left">Map</td>
<td class="org-left">Maps.filterKeys(Map, Predicate)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Maps.filterValues(Map, Predicate)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Maps.filterEntries(Map, Predicate)</td>
</tr>

<tr>
<td class="org-left">SortedMap</td>
<td class="org-left">Maps.filterKeys(SortedMap, Predicate)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Maps.filterValues(SortedMap, Predicate)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Maps.filterEntries(SortedMap, Predicate)</td>
</tr>

<tr>
<td class="org-left">Multimap</td>
<td class="org-left">Multimaps.filterKeys(Multimap, Predicate)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Multimaps.filterValues(Multimap, Predicate)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Multimaps.filterEntries(Multimap, Predicate)</td>
</tr>
</tbody>
</table>

<p>
*List的过滤视图被省略了，因为不能有效地支持类似get(int)的操作。请改用
Lists.newArrayList(Collections2.filter(list, predicate))做拷贝过滤。
</p>

<p>
除了简单过滤，Guava另外提供了若干用Predicate处理Iterable的工具——通常在Iterables
工具类中，或者是FluentIterable的”fluent”（链式调用）方法。
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Iterables方法签名</td>
<td class="org-left">说明</td>
<td class="org-left">另请参见</td>
</tr>

<tr>
<td class="org-left">boolean all(Iterable, Predicate)</td>
<td class="org-left">是否所有元素满足断言？懒实现：如果发现有元素不满足，不会继续迭代</td>
<td class="org-left">Iterators.all(Iterator, Predicate)FluentIterable.allMatch(Predicate)</td>
</tr>

<tr>
<td class="org-left">boolean any(Iterable, Predicate)</td>
<td class="org-left">是否有任意元素满足元素满足断言？懒实现：只会迭代到发现满足的元素</td>
<td class="org-left">Iterators.any(Iterator, Predicate)FluentIterable.anyMatch(Predicate)</td>
</tr>

<tr>
<td class="org-left">T find(Iterable, Predicate)</td>
<td class="org-left">循环并返回一个满足元素满足断言的元素，如果没有则抛出NoSuchElementException</td>
<td class="org-left">Iterators.find(Iterator, Predicate)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Iterables.find(Iterable, Predicate, T default)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Iterators.find(Iterator, Predicate, T default)</td>
</tr>

<tr>
<td class="org-left">Optional&lt;T&gt; tryFind(Iterable, Predicate)</td>
<td class="org-left">返回一个满足元素满足断言的元素，若没有则返回Optional.absent()</td>
<td class="org-left">Iterators.find(Iterator, Predicate)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Iterables.find(Iterable, Predicate, T default)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Iterators.find(Iterator, Predicate, T default)</td>
</tr>

<tr>
<td class="org-left">indexOf(Iterable, Predicate)</td>
<td class="org-left">返回第一个满足元素满足断言的元素索引值，若没有返回-1</td>
<td class="org-left">Iterators.indexOf(Iterator, Predicate)</td>
</tr>

<tr>
<td class="org-left">removeIf(Iterable, Predicate)</td>
<td class="org-left">移除所有满足元素满足断言的元素，实际调用Iterator.remove()方法</td>
<td class="org-left">Iterators.removeIf(Iterator, Predicate)</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orga719815" class="outline-3">
<h3 id="orga719815">函数</h3>
<div class="outline-text-3" id="text-orga719815">
<p>
到目前为止，函数最常见的用途为转换集合。同样，所有的Guava转换方法也返回原集合的
视图。
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">集合类型</th>
<th scope="col" class="org-left">转换方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Iterable</td>
<td class="org-left">Iterables.transform(Iterable, Function)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">FluentIterable.transform(Function)</td>
</tr>

<tr>
<td class="org-left">Iterator</td>
<td class="org-left">Iterators.transform(Iterator, Function)</td>
</tr>

<tr>
<td class="org-left">Collection</td>
<td class="org-left">Collections2.transform(Collection, Function)</td>
</tr>

<tr>
<td class="org-left">List</td>
<td class="org-left">Lists.transform(List, Function)</td>
</tr>

<tr>
<td class="org-left">Map*</td>
<td class="org-left">Maps.transformValues(Map, Function)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Maps.transformEntries(Map, EntryTransformer)</td>
</tr>

<tr>
<td class="org-left">SortedMap*</td>
<td class="org-left">Maps.transformValues(SortedMap, Function)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Maps.transformEntries(SortedMap, EntryTransformer)</td>
</tr>

<tr>
<td class="org-left">Multimap*</td>
<td class="org-left">Multimaps.transformValues(Multimap, Function)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Multimaps.transformEntries(Multimap, EntryTransformer)</td>
</tr>

<tr>
<td class="org-left">ListMultimap*</td>
<td class="org-left">Multimaps.transformValues(ListMultimap, Function)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Multimaps.transformEntries(ListMultimap, EntryTransformer)</td>
</tr>

<tr>
<td class="org-left">Table</td>
<td class="org-left">Tables.transformValues(Table, Function)</td>
</tr>
</tbody>
</table>

<p>
*Map和Multimap有特殊的方法，其中有个EntryTransformer&lt;K, V1, V2&gt;参数，它可以使用
旧的键值来计算，并且用计算结果替换旧值。
</p>

<p>
*对Set的转换操作被省略了，因为不能有效支持contains(Object)操作——译者注：懒视图实
际上不会全部计算转换后的Set元素，因此不能高效地支持contains(Object)。请改用
Sets.newHashSet(Collections2.transform(set, function))进行拷贝转换。
</p>
<pre class="example">
List&lt;String&gt; names;
Map&lt;String, Person&gt; personWithName;
List&lt;Person&gt; people = Lists.transform(names, Functions.forMap(personWithName));
ListMultimap&lt;String, String&gt; firstNameToLastNames;
// maps first names to all last names of people with that first name
ListMultimap&lt;String, String&gt; firstNameToName = Multimaps.transformEntries(firstNameToLastNames,
    new EntryTransformer&lt;String, String, String&gt; () {
        public String transformEntry(String firstName, String lastName) {
            return firstName + " " + lastName;
        }
    });
</pre>

<p>
可以组合Function使用的类包括：
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Ordering</td>
<td class="org-left">Ordering.onResultOf(Function)</td>
</tr>

<tr>
<td class="org-left">Predicate</td>
<td class="org-left">Predicates.compose(Predicate, Function)</td>
</tr>

<tr>
<td class="org-left">Equivalence</td>
<td class="org-left">Equivalence.onResultOf(Function)</td>
</tr>

<tr>
<td class="org-left">Supplier</td>
<td class="org-left">Suppliers.compose(Function, Supplier)</td>
</tr>

<tr>
<td class="org-left">Function</td>
<td class="org-left">Functions.compose(Function, Function)</td>
</tr>
</tbody>
</table>

<p>
此外，ListenableFuture API支持转换ListenableFuture。Futures也提供了接受
AsyncFunction参数的方法。AsyncFunction是Function的变种，它允许异步计算值。
</p>

<pre class="example">
Futures.transform(ListenableFuture, Function)
Futures.transform(ListenableFuture, Function, Executor)
Futures.transform(ListenableFuture, AsyncFunction)
Futures.transform(ListenableFuture, AsyncFunction, Executor)
</pre>
</div>
</div>
</div>

        </div>    </div>
    <div id="postamble" class="status"><div id="archive" style="padding-top: 3em; padding-bottom: 2em;"><a href="/archive.html">其它文章</a></div><script src="/js/av-min-1.5.0.js"></script>    </div>
</body>
</html>
