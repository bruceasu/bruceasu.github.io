<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://bruceasu.github.io/rss.xml"
      title="RSS feed for https://bruceasu.github.io/"/>
<title>Google_Guava官方教程（中文版）13-reflection解析</title>
<meta name="author" content="Bruce">
<meta name="referrer" content="no-referrer">
<link href= "/styles/org-manual.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="static/favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="/styles/font.css">
<link rel="stylesheet" media="screen and (min-width: 600px)" href="/styles/post.css">
<link rel="stylesheet" media="screen and (max-width: 600px)" href="/styles/post_mobile.css">
<link rel="stylesheet" media="screen and (min-width: 600px)" href="/styles/navigatebar.css">
<link rel="stylesheet" media="screen and (max-width: 600px)" href="/styles/navigatebar_mobile.css">
<link rel="stylesheet" href="/theme/highlight.css">

</head>
<body>
<div class="navigatebar">
    <div class="navigatebar-button navigatebar-mine">
        <a href="/index.html">Free World</a>
    </div>
    <div class="navigatebar-slogan">
        「生活可以更简单, 欢迎来到我的开源世界」
    </div>
    <div class="navigatebar-button">
        <a href="/index.html">Home</a>
    </div>
    <div class="navigatebar-button">
        <a href="/tags.html">Tags</a>
    </div>
    <div class="navigatebar-button">
        <a href="/rss.xml">Feeds</a>
    </div>
    <div class="navigatebar-button navigatebar-about">
        <a href="/about.html">About</a>
    </div>
</div>

      <div class="content-area">
<div class="title">Google_Guava官方教程（中文版）13-reflection解析</div>
<div class="category-area"><a href="https://bruceasu.github.io/tags.html#reprint"><div class="category">reprint</div></a> </div>
<div class="char-counter">2010-10-01</div>
        <div id="content">
<nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org9e04a76">举个例子：</a></li>
<li><a href="#orge1430f7">背景：类型擦除与反射</a></li>
<li><a href="#orgc06c333">介绍</a></li>
<li><a href="#org7e34cea">查询</a></li>
<li><a href="#org860dfa9">resolveType</a></li>
<li><a href="#org2ad7a05">Invokable</a></li>
<li><a href="#org9fa4650">Invokable:</a>
<ul>
<li><a href="#orgab4aefc">构造函数和工厂方法如何共享同样的代码？</a></li>
<li><a href="#org50d8838">List的List.get(int)返回类型是什么？</a></li>
</ul>
</li>
<li><a href="#orge69e2d7">Dynamic Proxies</a></li>
<li><a href="#org333e1fd">AbstractInvocationHandler</a></li>
<li><a href="#orgefaefde">ClassPath</a></li>
<li><a href="#org96afa64">Class Loading</a></li>
</ul>
</div>
</nav>
<p>
reflection解析
</p>

<p>
由于类型擦除，你不能够在运行时传递泛型类对象——你可能想强制转换它们，并假装这些对
象是有泛型的，但实际上它们没有。
</p>

<div id="outline-container-org9e04a76" class="outline-2">
<h2 id="org9e04a76">举个例子：</h2>
<div class="outline-text-2" id="text-org9e04a76">
<pre class="example">
ArrayList&lt;String&gt; stringList = Lists.newArrayList();
ArrayList&lt;Integer&gt; intList = Lists.newArrayList();
System.out.println(stringList.getClass().isAssignableFrom(intList.getClass()));
returns true, even though ArrayList&lt;String&gt; is not assignable from ArrayList&lt;Integer&gt;

</pre>

<p>
Guava提供了TypeToken, 它使用了基于反射的技巧甚至让你在运行时都能够巧妙的操作和查
询泛型类型。想象一下TypeToken是创建，操作，查询泛型类型（以及，隐含的类）对象的
方法。
</p>

<p>
Guice用户特别注意：TypeToken与类Guice的TypeLiteral很相似，但是有一个点特别不同：
它能够支持非具体化的类型，例如T，List&lt;T&gt;，甚至是List&lt;? extends Number&gt;；
TypeLiteral则不能支持。TypeToken也能支持序列化并且提供了很多额外的工具方法。
</p>
</div>
</div>

<div id="outline-container-orge1430f7" class="outline-2">
<h2 id="orge1430f7">背景：类型擦除与反射</h2>
<div class="outline-text-2" id="text-orge1430f7">
<p>
Java不能在运行时保留对象的泛型类型信息。如果你在运行时有一个ArrayList&lt;String&gt;对
象，你不能够判定这个对象是 有泛型类型ArrayList&lt;String&gt;的 —— 并且通过不安全的原始
类型，你可以将这个对象强制转换成ArrayList&lt;Object&gt;。
</p>

<p>
但是，反射允许你去检测方法和类的泛型类型。如果你实现了一个返回List的方法，并且你
用反射获得了这个方法的返回类型，你会获得代表List&lt;String&gt;的ParameterizedType。
</p>

<p>
TypeToken类使用这种变通的方法以最小的语法开销去支持泛型类型的操作。
</p>
</div>
</div>

<div id="outline-container-orgc06c333" class="outline-2">
<h2 id="orgc06c333">介绍</h2>
<div class="outline-text-2" id="text-orgc06c333">
<p>
获取一个基本的、原始类的TypeToken非常简单：
</p>
<pre class="example">
TypeToken&lt;String&gt; stringTok = TypeToken.of(String.class);
TypeToken&lt;Integer&gt; intTok = TypeToken.of(Integer.class);

</pre>

<p>
为获得一个含有泛型的类型的TypeToken —— 当你知道在编译时的泛型参数类型 —— 你使用一个空的匿名内部类：
</p>
<pre class="example">
TypeToken&lt;List&lt;String&gt;&gt; stringListTok = new TypeToken&lt;List&lt;String&gt;&gt;() {};

</pre>
<p>
或者你想故意指向一个通配符类型：
</p>
<pre class="example">
TypeToken&lt;Map&lt;?, ?&gt;&gt; wildMapTok = new TypeToken&lt;Map&lt;?, ?&gt;&gt;() {};

</pre>
<p>
TypeToken提供了一种方法来动态的解决泛型类型参数，如下所示：
</p>
<pre class="example">
static &lt;K, V&gt; TypeToken&lt;Map&lt;K, V&gt;&gt; mapToken(TypeToken&lt;K&gt; keyToken, TypeToken&lt;V&gt; valueToken) {
    return new TypeToken&lt;Map&lt;K, V&gt;&gt;() {}
        .where(new TypeParameter&lt;K&gt;() {}, keyToken)
        .where(new TypeParameter&lt;V&gt;() {}, valueToken);
}
...
TypeToken&lt;Map&lt;String, BigInteger&gt;&gt; mapToken = mapToken(
    TypeToken.of(String.class),
    TypeToken.of(BigInteger.class)
);
TypeToken&lt;Map&lt;Integer, Queue&lt;String&gt;&gt;&gt; complexToken = mapToken(
   TypeToken.of(Integer.class),
   new TypeToken&lt;Queue&lt;String&gt;&gt;() {}
);

</pre>

<p>
注意如果mapToken只是返回了new TypeToken&gt;()，它实际上不能把具体化的类型分配到K和V上面，举个例子
</p>
<pre class="example">
class Util {
    static &lt;K, V&gt; TypeToken&lt;Map&lt;K, V&gt;&gt; incorrectMapToken() {
        return new TypeToken&lt;Map&lt;K, V&gt;&gt;() {};
    }
}
System.out.println(Util.&lt;String, BigInteger&gt;incorrectMapToken());
// just prints out "java.util.Map&lt;K, V&gt;"

</pre>

<p>
或者，你可以通过一个子类（通常是匿名）来捕获一个泛型类型并且这个子类也可以用来替换知道参数类型的上下文类。
</p>
<pre class="example">
abstract class IKnowMyType&lt;T&gt; {
    TypeToken&lt;T&gt; type = new TypeToken&lt;T&gt;(getClass()) {};
}
...
new IKnowMyType&lt;String&gt;() {}.type; // returns a correct TypeToken&lt;String&gt;

</pre>

<p>
使用这种技术，你可以，例如，获得知道他们的元素类型的类。
</p>
</div>
</div>

<div id="outline-container-org7e34cea" class="outline-2">
<h2 id="org7e34cea">查询</h2>
<div class="outline-text-2" id="text-org7e34cea">
<p>
TypeToken支持很多种类能支持的查询，但是也会把通用的查询约束考虑在内。
支持的查询操作包括：
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">getType()</td>
<td class="org-left">获得包装的java.lang.reflect.Type.</td>
</tr>

<tr>
<td class="org-left">getRawType()</td>
<td class="org-left">返回大家熟知的运行时类</td>
</tr>

<tr>
<td class="org-left">getSubtype(Class&lt;?&gt;)</td>
<td class="org-left">返回那些有特定原始类的子类型。举个例子，如果这有一个Iterable并且参数是List.class，那么返回将是List。</td>
</tr>

<tr>
<td class="org-left">getSupertype(Class&lt;?&gt;)</td>
<td class="org-left">产生这个类型的超类，这个超类是指定的原始类型。举个例子，如果这是一个Set并且参数是Iterable.class，结果将会是Iterable。</td>
</tr>

<tr>
<td class="org-left">isAssignableFrom(type)</td>
<td class="org-left">如果这个类型是 assignable from 指定的类型，并且考虑泛型参数，返回true。List&lt;? extends Number&gt;是assignable from List，但List没有.</td>
</tr>

<tr>
<td class="org-left">getTypes()</td>
<td class="org-left">返回一个Set，包含了这个所有接口，子类和类是这个类型的类。返回的Set同样提供了classes()和interfaces()方法允许你只浏览超类和接口类。</td>
</tr>

<tr>
<td class="org-left">isArray()</td>
<td class="org-left">检查某个类型是不是数组，甚至是&lt;? extends A[]&gt;。</td>
</tr>

<tr>
<td class="org-left">getComponentType()</td>
<td class="org-left">返回组件类型数组。</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-org860dfa9" class="outline-2">
<h2 id="org860dfa9">resolveType</h2>
<div class="outline-text-2" id="text-org860dfa9">
<p>
resolveType是一个可以用来“替代”context token（译者：不知道怎么翻译，只好去
stackoverflow去问了）中的类型参数的一个强大而复杂的查询操作。例如，
</p>
<pre class="example">
TypeToken&lt;Function&lt;Integer, String&gt;&gt; funToken = new TypeToken&lt;Function&lt;Integer, String&gt;&gt;() {};
TypeToken&lt;?&gt; funResultToken = funToken.resolveType(Function.class.getTypeParameters()[1]));
// returns a TypeToken&lt;String&gt;
TypeToken将Java提供的TypeVariables和context token中的类型变量统一起来。这可以被用来一般性地推断出在一个类型相关方法的返回类型：
TypeToken&lt;Map&lt;String, Integer&gt;&gt; mapToken = new TypeToken&lt;Map&lt;String, Integer&gt;&gt;() {};
TypeToken&lt;?&gt; entrySetToken = mapToken.resolveType(Map.class.getMethod("entrySet").getGenericReturnType());
// returns a TypeToken&lt;Set&lt;Map.Entry&lt;String, Integer&gt;&gt;&gt;

</pre>
</div>
</div>

<div id="outline-container-org2ad7a05" class="outline-2">
<h2 id="org2ad7a05">Invokable</h2>
<div class="outline-text-2" id="text-org2ad7a05">
<p>
Guava的Invokable是对java.lang.reflect.Method和java.lang.reflect.Constructor的流
式包装。它简化了常见的反射代码的使用。一些使用例子：
</p>

<p>
方法是否是public的?
JDK:
</p>
<pre class="example">
Modifier.isPublic(method.getModifiers())
Invokable:
invokable.isPublic()

</pre>

<p>
方法是否是package private?
JDK:
</p>
<pre class="example">
: !(Modifier.isPrivate(method.getModifiers()) || Modifier.isPublic(method.getModifiers()))
Invokable:
invokable.isPackagePrivate()

</pre>

<p>
方法是否能够被子类重写？
JDK:
</p>
<pre class="example">
!(Modifier.isFinal(method.getModifiers()) || Modifiers.isPrivate(method.getModifiers()) || Modifiers.isStatic(method.getModifiers()) || Modifiers.isFinal(method.getDeclaringClass().getModifiers()))

</pre>
</div>
</div>

<div id="outline-container-org9fa4650" class="outline-2">
<h2 id="org9fa4650">Invokable:</h2>
<div class="outline-text-2" id="text-org9fa4650">
<p>
invokable.isOverridable()
</p>

<p>
方法的第一个参数是否被定义了注解@Nullable？
JDK:
</p>
<pre class="example">
for (Annotation annotation : method.getParameterAnnotations[0]) {
    if (annotation instanceof Nullable) {
        return true;
    }
}
return false;
Invokable:
invokable.getParameters().get(0).isAnnotationPresent(Nullable.class)

</pre>
</div>

<div id="outline-container-orgab4aefc" class="outline-3">
<h3 id="orgab4aefc">构造函数和工厂方法如何共享同样的代码？</h3>
<div class="outline-text-3" id="text-orgab4aefc">
<p>
你是否很想重复自己，因为你的反射代码需要以相同的方式工作在构造函数和工厂方法中？
Invokable提供了一个抽象的概念。下面的代码适合任何一种方法或构造函数：
</p>
<pre class="example">
invokable.isPublic();
invokable.getParameters();
invokable.invoke(object, args);

</pre>
</div>
</div>

<div id="outline-container-org50d8838" class="outline-3">
<h3 id="org50d8838">List的List.get(int)返回类型是什么？</h3>
<div class="outline-text-3" id="text-org50d8838">
<p>
Invokable提供了与众不同的类型解决方案：
</p>
<pre class="example">
Invokable&lt;List&lt;String&gt;, ?&gt; invokable = new TypeToken&lt;List&lt;String&gt;&gt;()        {}.method(getMethod);
invokable.getReturnType(); // String.class

</pre>
</div>
</div>
</div>

<div id="outline-container-orge69e2d7" class="outline-2">
<h2 id="orge69e2d7">Dynamic Proxies</h2>
<div class="outline-text-2" id="text-orge69e2d7">
<p>
newProxy()
</p>

<p>
实用方法Reflection.newProxy(Class, InvocationHandler)是一种更安全，更方便的API，
它只有一个单一的接口类型需要被代理来创建Java动态代理时
</p>

<p>
JDK:
</p>
<pre class="example">
Foo foo = (Foo) Proxy.newProxyInstance(
Foo.class.getClassLoader(),
new Class&lt;?&gt;[] {Foo.class},
invocationHandler);

</pre>

<p>
Guava:
</p>
<pre class="example">
Foo foo = Reflection.newProxy(Foo.class, invocationHandler);

</pre>
</div>
</div>

<div id="outline-container-org333e1fd" class="outline-2">
<h2 id="org333e1fd">AbstractInvocationHandler</h2>
<div class="outline-text-2" id="text-org333e1fd">
<p>
有时候你可能想动态代理能够更直观的支持equals()，hashCode()和toString()，那就是：
</p>
<ol class="org-ol">
<li>一个代理实例equal另外一个代理实例，只要他们有同样的接口类型和equal的
invocation handlers。</li>
<li>一个代理实例的toString()会被代理到invocation handler的toString()，这样更容易
自定义。</li>
</ol>
<p>
AbstractInvocationHandler实现了以上逻辑。
</p>

<p>
除此之外，AbstractInvocationHandler确保传递给handleInvocation(Object, Method,
Object[]))的参数数组永远不会空，从而减少了空指针异常的机会。
</p>
</div>
</div>

<div id="outline-container-orgefaefde" class="outline-2">
<h2 id="orgefaefde">ClassPath</h2>
<div class="outline-text-2" id="text-orgefaefde">
<p>
严格来讲，Java没有平台无关的方式来浏览类和类资源。不过一定的包或者工程下，还是能
够实现的，比方说，去检查某个特定的工程的惯例或者某种一直遵从的约束。
</p>

<p>
ClassPath是一种实用工具，它提供尽最大努力的类路径扫描。用法很简单：
</p>
<pre class="example">
ClassPath classpath = ClassPath.from(classloader); // scans the class path used by classloader
for (ClassPath.ClassInfo classInfo : classpath.getTopLevelClasses("com.mycomp.mypackage")) {
  ...
}

</pre>

<p>
在上面的例子中，ClassInfo是被加载类的句柄。它允许程序员去检查类的名字和包的名字，
让类直到需要的时候才被加载。
</p>

<p>
值得注意的是，ClassPath是一个尽力而为的工具。它只扫描jar文件中或者某个文件目录下
的class文件。也不能扫描非URLClassLoader的自定义class loader管理的class，所以不要
将它用于关键任务生产任务。
</p>
</div>
</div>

<div id="outline-container-org96afa64" class="outline-2">
<h2 id="org96afa64">Class Loading</h2>
<div class="outline-text-2" id="text-org96afa64">
<p>
工具方法Reflection.initialize(Class…)能够确保特定的类被初始化——执行任何静态初始
化。
</p>

<p>
使用这种方法的是一个代码异味，因为静态伤害系统的可维护性和可测试性。在有些情况下，
你别无选择，而与传统的框架，操作间，这一方法有助于保持代码不那么丑。
</p>
</div>
</div>

        </div>    </div>
    <div id="postamble" class="status"><div id="archive" style="padding-top: 3em; padding-bottom: 2em;"><a href="/archive.html">其它文章</a></div><script src="/js/av-min-1.5.0.js"></script>    </div>
</body>
</html>
