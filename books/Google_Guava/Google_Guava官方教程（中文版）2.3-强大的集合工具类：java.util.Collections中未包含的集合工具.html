<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
<title>Free World - Google_Guava官方教程（中文版）2.3-强大的集合工具类：java.util.Collections中未包含的集合工具</title>
<meta name="author" content="Bruce">
<meta name="referrer" content="no-referrer">
<link href= "https://bruceasu.github.io/styles/org-manual.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="static/favicon.ico">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="https://bruceasu.github.io/styles/font.css">
<link rel="stylesheet" media="screen and (min-width: 600px)" href="https://bruceasu.github.io/styles/post.css">
<link rel="stylesheet" media="screen and (max-width: 600px)" href="https://bruceasu.github.io/styles/post_mobile.css">
<link rel="stylesheet" media="screen and (min-width: 600px)" href="https://bruceasu.github.io/styles/navigatebar.css">
<link rel="stylesheet" media="screen and (max-width: 600px)" href="https://bruceasu.github.io/styles/navigatebar_mobile.css">
<link rel="stylesheet" href="https://bruceasu.github.io/theme/highlight.css">

    <style>
        /*生成博客目录的CSS*/
        #sideBar {
            font-size: 12px;
            font-family: Arial, Helvetica, sans-serif;
            text-align: left;
            position: fixed; /*将div的位置固定到距离top:50px，right:0px的位置，这样div就会处在最右边的位置，距离顶部50px*/
            top: 100px;
            right: 0px;
            min-height: 108px;
            width: auto;
            height: auto;
        }

        #sideBarTab {
            float: left;
            width: 30px;
            border: 1px solid #e5e5e5;
            border-right: none;
            text-align: center;
            background: #ffffff;
        }

        #sideBarTab * {
            margin-top: 10px;
        }

        #sideBarContents {
            float: left;
            overflow: auto;
            overflow-x: hidden;
        !important;
            width: 200px;
            min-height: 128px;
            max-height: 460px;
            border: 1px solid #e5e5e5;
            border-right: none;
            background: #ffffff;
        }

        #sideBarContents ul {
            margin: 0;
            padding: 0;
        }

        #sideBarContents li {
            margin-top: 5px;
            margin-left: 5px;
        }

        #sideBarContents li {
            cursor: pointer;
        }

        #sideBarContents li:hover {
            color: #A7995A;
        }


    </style>
</head>
<body>
<div class="navigatebar">
    <div class="navigatebar-button navigatebar-mine">
        <a href="https://bruceasu.github.io/index.html">Free World</a>
    </div>
    <div class="navigatebar-slogan">
        「生活可以更简单, 欢迎来到我的开源世界」
    </div>
    <div class="navigatebar-button">
        <a href="https://bruceasu.github.io/index.html">Home</a>
    </div>
    <div class="navigatebar-button">
        <a href="https://bruceasu.github.io/tags.html">Tags</a>
    </div>
    <div class="navigatebar-button">
        <a href="https://bruceasu.github.io/wiki/index.html">Wiki</a>
    </div>
    <div class="navigatebar-button">
        <a href="https://bruceasu.github.io/books/index.html">Books</a>
    </div>
    <div class="navigatebar-button">
        <a href="https://bruceasu.github.io/archive.html">Archives</a>
    </div>
    <div class="navigatebar-button navigatebar-about">
        <a href="https://bruceasu.github.io/about.html">About</a>
    </div>
</div>


<div class="content-area">
    <div class="title">Google_Guava官方教程（中文版）2.3-强大的集合工具类：java.util.Collections中未包含的集合工具</div>
    
    <a href="https://bruceasu.github.io/tags.html#reprint">
        <div class="category">reprint</div>
    </a>
    
    <div class="char-counter"> Fri Oct 01 20:48:00 CST 2010</div>
    <div id="content">
        <p>强大的集合工具类：java.util.Collections中未包含的集合工具</p>
<p>任何对JDK集合框架有经验的程序员都熟悉和喜欢java.util.Collections包含的工具方法。 Guava沿着这些路线提供了更多的工具方法：适用于所有集合的静态方法。这是Guava最流行 和成熟的部分之一。我们用相对直观的方式把工具类与特定集合接口的对应关系归纳如下：</p>
<table>
<thead>
<tr class="header">
<th>集合接口</th>
<th>属于JDK还是Guava</th>
<th>对应的Guava工具类</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Collection</td>
<td>JDK</td>
<td>Collections2：不要和java.util.Collections混淆</td>
</tr>
<tr class="even">
<td>List</td>
<td>JDK</td>
<td>Lists</td>
</tr>
<tr class="odd">
<td>Set</td>
<td>JDK</td>
<td>Sets</td>
</tr>
<tr class="even">
<td>SortedSet</td>
<td>JDK</td>
<td>Sets</td>
</tr>
<tr class="odd">
<td>Map</td>
<td>JDK</td>
<td>Maps</td>
</tr>
<tr class="even">
<td>SortedMap</td>
<td>JDK</td>
<td>Maps</td>
</tr>
<tr class="odd">
<td>Queue</td>
<td>JDK</td>
<td>Queues</td>
</tr>
<tr class="even">
<td>Multiset</td>
<td>Guava</td>
<td>Multisets</td>
</tr>
<tr class="odd">
<td>Multimap</td>
<td>Guava</td>
<td>Multimaps</td>
</tr>
<tr class="even">
<td>BiMap</td>
<td>Guava</td>
<td>Maps</td>
</tr>
<tr class="odd">
<td>Table</td>
<td>Guava</td>
<td>Tables</td>
</tr>
</tbody>
</table>
<p>在找类似转化、过滤的方法？请看第四章，函数式风格。</p>
<h1 id="静态工厂方法">静态工厂方法</h1>
<p>在JDK 7之前，构造新的范型集合时要讨厌地重复声明范型：</p>
<pre class="example"><code>List&lt;TypeThatsTooLongForItsOwnGood&gt; list = new ArrayList&lt;TypeThatsTooLongForItsOwnGood&gt;();
</code></pre>
<p>我想我们都认为这很讨厌。因此Guava提供了能够推断范型的静态工厂方法：</p>
<pre class="example"><code>List&lt;TypeThatsTooLongForItsOwnGood&gt; list = Lists.newArrayList();
Map&lt;KeyType, LongishValueType&gt; map = Maps.newLinkedHashMap();

</code></pre>
<p>可以肯定的是，JDK7版本的钻石操作符(&lt;&gt;)没有这样的麻烦：</p>
<pre class="example"><code>List&lt;TypeThatsTooLongForItsOwnGood&gt; list = new ArrayList&lt;&gt;();
</code></pre>
<p>但Guava的静态工厂方法远不止这么简单。用工厂方法模式，我们可以方便地在初始化时就指定起始元素。</p>
<pre class="example"><code>Set&lt;Type&gt; copySet = Sets.newHashSet(elements);
List&lt;String&gt; theseElements = Lists.newArrayList(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;);

</code></pre>
<p>此外，通过为工厂方法命名（Effective Java第一条），我们可以提高集合初始化大小的可读性：</p>
<pre class="example"><code>List&lt;Type&gt; exactly100 = Lists.newArrayListWithCapacity(100);
List&lt;Type&gt; approx100 = Lists.newArrayListWithExpectedSize(100);
Set&lt;Type&gt; approx100Set = Sets.newHashSetWithExpectedSize(100);

</code></pre>
<p>确切的静态工厂方法和相应的工具类一起罗列在下面的章节。</p>
<p>注意：Guava引入的新集合类型没有暴露原始构造器，也没有在工具类中提供初始化方法。 而是直接在集合类中提供了静态工厂方法，例如：</p>
<pre class="example"><code>Multiset&lt;String&gt; multiset = HashMultiset.create();
</code></pre>
<h1 id="iterables">Iterables</h1>
<p>在可能的情况下，Guava提供的工具方法更偏向于接受Iterable而不是Collection类型。在 Google，对于不存放在主存的集合 ——比如从数据库或其他数据中心收集的结果集，因为实 际上还没有攫取全部数据，这类结果集都不能支持类似size()的操作 ——通常都不会用 Collection类型来表示。</p>
<p>因此，很多你期望的支持所有集合的操作都在Iterables类中。大多数Iterables方法有一个 在Iterators类中的对应版本，用来处理Iterator。</p>
<p>截至Guava 1.2版本，Iterables使用FluentIterable类进行了补充，它包装了一个Iterable 实例，并对许多操作提供了”fluent”（链式调用）语法。</p>
<p>下面列出了一些最常用的工具方法，但更多Iterables的函数式方法将在第四章讨论。</p>
<h2 id="常规方法">常规方法</h2>
<table>
<tbody>
<tr class="odd">
<td>concat(Iterable&lt;Iterable&gt;)</td>
<td>串联多个iterables的懒视图*</td>
<td>concat(Iterable…)</td>
</tr>
<tr class="even">
<td>frequency(Iterable, Object)</td>
<td>返回对象在iterable中出现的次数</td>
<td>与Collections.frequency (Collection,   Object)比较；Multiset</td>
</tr>
<tr class="odd">
<td>partition(Iterable, int)</td>
<td>把iterable按指定大小分割，得到的子集都不能进行修改操作</td>
<td>Lists.partition(List, int)；paddedPartition(Iterable, int)</td>
</tr>
<tr class="even">
<td>getFirst(Iterable, T default)</td>
<td>返回iterable的第一个元素，若iterable为空则返回默认值</td>
<td>与Iterable.iterator(). next()比较;FluentIterable.first()</td>
</tr>
<tr class="odd">
<td>getLast(Iterable)</td>
<td>返回iterable的最后一个元素，若iterable为空则抛出NoSuchElementException</td>
<td>getLast(Iterable, T default)；FluentIterable.last()</td>
</tr>
<tr class="even">
<td>elementsEqual(Iterable, Iterable)</td>
<td>如果两个iterable中的所有元素相等且顺序一致，返回true</td>
<td>与List.equals(Object)比较</td>
</tr>
<tr class="odd">
<td>unmodifiableIterable(Iterable)</td>
<td>返回iterable的不可变视图</td>
<td>与Collections. unmodifiableCollection(Collection)比较</td>
</tr>
<tr class="even">
<td>limit(Iterable, int)</td>
<td>限制iterable的元素个数限制给定值</td>
<td>FluentIterable.limit(int)</td>
</tr>
<tr class="odd">
<td>getOnlyElement(Iterable)</td>
<td>获取iterable中唯一的元素，如果iterable为空或有多个元素，则快速失败</td>
<td>getOnlyElement(Iterable, T default)</td>
</tr>
</tbody>
</table>
<p>*译者注：懒视图意味着如果还没访问到某个iterable中的元素，则不会对它进行串联操作。</p>
<pre class="example"><code>Iterable&lt;Integer&gt; concatenated = Iterables.concat(
        Ints.asList(1, 2, 3),
        Ints.asList(4, 5, 6)); // concatenated包括元素 1, 2, 3, 4, 5, 6
String lastAdded = Iterables.getLast(myLinkedHashSet);
String theElement = Iterables.getOnlyElement(thisSetIsDefinitelyASingleton);
//如果set不是单元素集，就会出错了！

</code></pre>
<h2 id="与collection方法相似的工具方法">与Collection方法相似的工具方法</h2>
<p>通常来说，Collection的实现天然支持操作其他Collection，但却不能操作Iterable。</p>
<p>下面的方法中，如果传入的Iterable是一个Collection实例，则实际操作将会委托给相应的 Collection接口方法。例如，往 Iterables.size方法传入是一个Collection实例，它不会 真的遍历iterator获取大小，而是直接调用 Collection.size。</p>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>类似的Collection方法</th>
<th>等价的FluentIterable方法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>addAll(Collection addTo, Iterable toAdd)</td>
<td>Collection.addAll(Collection)</td>
<td></td>
</tr>
<tr class="even">
<td>contains(Iterable, Object)</td>
<td>Collection.contains(Object)</td>
<td>FluentIterable.contains(Object)</td>
</tr>
<tr class="odd">
<td>removeAll(Iterable removeFrom, Collection toRemove)</td>
<td>Collection.removeAll(Collection)</td>
<td></td>
</tr>
<tr class="even">
<td>retainAll(Iterable removeFrom, Collection toRetain)</td>
<td>Collection.retainAll(Collection)</td>
<td></td>
</tr>
<tr class="odd">
<td>size(Iterable)</td>
<td>Collection.size()</td>
<td>FluentIterable.size()</td>
</tr>
<tr class="even">
<td>toArray(Iterable, Class)</td>
<td>Collection.toArray(T[])</td>
<td>FluentIterable.toArray(Class)</td>
</tr>
<tr class="odd">
<td>isEmpty(Iterable)</td>
<td>Collection.isEmpty()</td>
<td>FluentIterable.isEmpty()</td>
</tr>
<tr class="even">
<td>get(Iterable, int)</td>
<td>List.get(int)</td>
<td>FluentIterable.get(int)</td>
</tr>
<tr class="odd">
<td>toString(Iterable)</td>
<td>Collection.toString()</td>
<td>FluentIterable.toString()</td>
</tr>
</tbody>
</table>
<h2 id="fluentiterable">FluentIterable</h2>
<p>除了上面和第四章提到的方法，FluentIterable还有一些便利方法用来把自己拷贝到不可变集合</p>
<table>
<tbody>
<tr class="odd">
<td>ImmutableList</td>
<td></td>
</tr>
<tr class="even">
<td>ImmutableSet</td>
<td>toImmutableSet()</td>
</tr>
<tr class="odd">
<td>ImmutableSortedSet</td>
<td>toImmutableSortedSet(Comparator)</td>
</tr>
</tbody>
</table>
<h1 id="lists">Lists</h1>
<h2 id="除了静态工厂方法和函数式编程方法lists为list类型的对象提供了若干工具方法">除了静态工厂方法和函数式编程方法，Lists为List类型的对象提供了若干工具方法。</h2>
<table>
<tbody>
<tr class="odd">
<td>方法</td>
<td>描述</td>
</tr>
<tr class="even">
<td>partition(List, int)</td>
<td>把List按指定大小分割</td>
</tr>
<tr class="odd">
<td>reverse(List)</td>
<td>返回给定List的反转视图。</td>
</tr>
<tr class="even">
<td></td>
<td>注: 如果List是不可变的，考虑改用ImmutableList.reverse()。</td>
</tr>
</tbody>
</table>
<pre class="example"><code>List countUp = Ints.asList(1, 2, 3, 4, 5);
List countDown = Lists.reverse(theList); // {5, 4, 3, 2, 1}
List&lt;List&gt; parts = Lists.partition(countUp, 2);//{{1,2}, {3,4}, {5}}
</code></pre>
<h2 id="静态工厂方法-1">静态工厂方法</h2>
<p>Lists提供如下静态工厂方法：</p>
<table>
<thead>
<tr class="header">
<th>具体实现类型</th>
<th>工厂方法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ArrayList</td>
<td>basic, with elements, from Iterable,</td>
</tr>
<tr class="even">
<td></td>
<td>with exact capacity, with expected size, from Iterator</td>
</tr>
<tr class="odd">
<td>LinkedList</td>
<td>basic, from Iterable</td>
</tr>
</tbody>
</table>
<h1 id="sets">Sets</h1>
<p>Sets工具类包含了若干好用的方法。</p>
<h2 id="集合理论方法">集合理论方法</h2>
<p>我们提供了很多标准的集合运算（Set-Theoretic）方法，这些方法接受Set参数并返回 SetView，可用于：</p>
<ul>
<li>直接当作Set使用，因为SetView也实现了Set接口；</li>
<li>用copyInto(Set)拷贝进另一个可变集合；</li>
<li>用immutableCopy()对自己做不可变拷贝。</li>
</ul>
<div class="line-block">union(Set, Set)<br />
intersection(Set, Set)<br />
difference(Set, Set)<br />
symmetricDifference(Set,   Set)</div>
<p>使用范例：</p>
<pre class="example"><code>Set&lt;String&gt; wordsWithPrimeLength = ImmutableSet.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;);
Set&lt;String&gt; primes = ImmutableSet.of(&quot;two&quot;, &quot;three&quot;, &quot;five&quot;, &quot;seven&quot;);
SetView&lt;String&gt; intersection = Sets.intersection(primes,wordsWithPrimeLength);
// intersection包含&quot;two&quot;, &quot;three&quot;, &quot;seven&quot;
return intersection.immutableCopy();//可以使用交集，但不可变拷贝的读取效率更高
</code></pre>
<h2 id="其他set工具方法">其他Set工具方法</h2>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>描述</th>
<th>另请参见</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>cartesianProduct(List&lt;Set&gt;)</td>
<td>返回所有集合的笛卡儿积</td>
<td>cartesianProduct(Set…)</td>
</tr>
<tr class="even">
<td>powerSet(Set)</td>
<td>返回给定集合的所有子集</td>
<td></td>
</tr>
</tbody>
</table>
<pre class="example"><code>Set&lt;String&gt; animals = ImmutableSet.of(&quot;gerbil&quot;, &quot;hamster&quot;);
Set&lt;String&gt; fruits = ImmutableSet.of(&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;);
Set&lt;List&lt;String&gt;&gt; product = Sets.cartesianProduct(animals, fruits);
// {{&quot;gerbil&quot;, &quot;apple&quot;}, {&quot;gerbil&quot;, &quot;orange&quot;}, {&quot;gerbil&quot;, &quot;banana&quot;},
//  {&quot;hamster&quot;, &quot;apple&quot;}, {&quot;hamster&quot;, &quot;orange&quot;}, {&quot;hamster&quot;, &quot;banana&quot;}}
Set&lt;Set&lt;String&gt;&gt; animalSets = Sets.powerSet(animals);
// {{}, {&quot;gerbil&quot;}, {&quot;hamster&quot;}, {&quot;gerbil&quot;, &quot;hamster&quot;}}
</code></pre>
<h2 id="静态工厂方法-2">静态工厂方法</h2>
<p>Sets提供如下静态工厂方法：</p>
<table>
<thead>
<tr class="header">
<th>具体实现类型</th>
<th>工厂方法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>HashSet</td>
<td>basic, with elements, from Iterable, with expected size, from Iterator</td>
</tr>
<tr class="even">
<td>LinkedHashSet</td>
<td>basic, from Iterable, with expected size</td>
</tr>
<tr class="odd">
<td>TreeSet</td>
<td>basic, with Comparator, from Iterable</td>
</tr>
</tbody>
</table>
<h1 id="maps">Maps</h1>
<p>Maps类有若干值得单独说明的、很酷的方法。</p>
<h2 id="uniqueindex">uniqueIndex</h2>
<pre class="example"><code>Maps.uniqueIndex(Iterable,Function)
</code></pre>
<p>通常针对的场景是：有一组对象，它们在某个属性上分别有独一无二的值，而我们希望能够 按照这个属性值查找对象——译者注：这个方法返回一个Map，键为Function返回的属性值， 值为Iterable中相应的元素，因此我们可以反复用这个Map进行查找操作。</p>
<p>比方说，我们有一堆字符串，这些字符串的长度都是独一无二的，而我们希望能够按照特定 长度查找字符串：</p>
<pre class="example"><code>ImmutableMap&lt;Integer, String&gt; stringsByIndex = Maps.uniqueIndex(strings,
    new Function&lt;String, Integer&gt; () {
        public Integer apply(String string) {
            return string.length();
        }
    })
</code></pre>
<p>如果索引值不是独一无二的，请参见下面的Multimaps.index方法。</p>
<h2 id="difference">difference</h2>
<pre class="example"><code>Maps.difference(Map, Map)
</code></pre>
<p>用来比较两个Map以获取所有不同点。该方法返回MapDifference对象，把不同点的维恩图分 解为：</p>
<table>
<tbody>
<tr class="odd">
<td>entriesInCommon()</td>
<td>两个Map中都有的映射项，包括匹配的键与值</td>
</tr>
<tr class="even">
<td>entriesDiffering()</td>
<td>键相同但是值不同值映射项。</td>
</tr>
<tr class="odd">
<td></td>
<td>返回的Map的值类型为MapDifference.ValueDifference，以表示左右两个不同的值</td>
</tr>
<tr class="even">
<td>entriesOnlyOnLeft()</td>
<td>键只存在于左边Map的映射项</td>
</tr>
<tr class="odd">
<td>entriesOnlyOnRight()</td>
<td>键只存在于右边Map的映射项</td>
</tr>
</tbody>
</table>
<pre class="example"><code>Map&lt;String, Integer&gt; left = ImmutableMap.of(&quot;a&quot;, 1, &quot;b&quot;, 2, &quot;c&quot;, 3);
Map&lt;String, Integer&gt; left = ImmutableMap.of(&quot;a&quot;, 1, &quot;b&quot;, 2, &quot;c&quot;, 3);
MapDifference&lt;String, Integer&gt; diff = Maps.difference(left, right);
diff.entriesInCommon(); // {&quot;b&quot; =&gt; 2}
diff.entriesInCommon(); // {&quot;b&quot; =&gt; 2}
diff.entriesOnlyOnLeft(); // {&quot;a&quot; =&gt; 1}
diff.entriesOnlyOnRight(); // {&quot;d&quot; =&gt; 5}
</code></pre>
<h2 id="处理bimap的工具方法">处理BiMap的工具方法</h2>
<p>Guava中处理BiMap的工具方法在Maps类中，因为BiMap也是一种Map实现。</p>
<table>
<tbody>
<tr class="odd">
<td>BiMap工具方法</td>
<td>相应的Map工具方法</td>
</tr>
<tr class="even">
<td>synchronizedBiMap(BiMap)</td>
<td>Collections.synchronizedMap(Map)</td>
</tr>
<tr class="odd">
<td>unmodifiableBiMap(BiMap)</td>
<td>Collections.unmodifiableMap(Map)</td>
</tr>
</tbody>
</table>
<h2 id="静态工厂方法-3">静态工厂方法</h2>
<p>Maps提供如下静态工厂方法：</p>
<table>
<thead>
<tr class="header">
<th>具体实现类型</th>
<th>工厂方法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>HashMap</td>
<td>basic, from Map, with expected size</td>
</tr>
<tr class="even">
<td>LinkedHashMap</td>
<td>basic, from Map</td>
</tr>
<tr class="odd">
<td>TreeMap</td>
<td>basic, from Comparator, from SortedMap</td>
</tr>
<tr class="even">
<td>EnumMap</td>
<td>from Class, from Map</td>
</tr>
<tr class="odd">
<td>ConcurrentMap：支持所有操作</td>
<td>basic</td>
</tr>
<tr class="even">
<td>IdentityHashMap</td>
<td>basic</td>
</tr>
</tbody>
</table>
<h1 id="multisets">Multisets</h1>
<p>标准的Collection操作会忽略Multiset重复元素的个数，而只关心元素是否存在于Multiset 中，如containsAll方法。为此，Multisets提供了若干方法，以顾及Multiset元素的重复性：</p>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>说明</th>
<th>和Collection方法的区别</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>containsOccurrences(Multiset   sup, Multiset sub)</td>
<td>对任意o，如果sub.count(o)&lt;=super.count(o)，返回true</td>
<td>Collection.containsAll忽略个数，而只关心sub的元素是否都在super中</td>
</tr>
<tr class="even">
<td>removeOccurrences(Multiset   removeFrom, Multiset toRemove)</td>
<td>对toRemove中的重复元素，仅在removeFrom中删除相同个数。</td>
<td>Collection.removeAll移除所有出现在toRemove的元素</td>
</tr>
<tr class="odd">
<td>retainOccurrences(Multiset   removeFrom, Multiset toRetain)</td>
<td>修改removeFrom，以保证任意o都符合removeFrom.count(o)&lt;=toRetain.count(o)</td>
<td>Collection.retainAll保留所有出现在toRetain的元素</td>
</tr>
<tr class="even">
<td>intersection(Multiset,   Multiset)</td>
<td>返回两个multiset的交集;</td>
<td>没有类似方法</td>
</tr>
</tbody>
</table>
<pre class="example"><code>Multiset&lt;String&gt; multiset1 = HashMultiset.create();
multiset1.add(&quot;a&quot;, 2);
Multiset&lt;String&gt; multiset2 = HashMultiset.create();
multiset2.add(&quot;a&quot;, 5);
multiset1.containsAll(multiset2); //返回true；因为包含了所有不重复元素，
//虽然multiset1实际上包含2个&quot;a&quot;，而multiset2包含5个&quot;a&quot;
Multisets.containsOccurrences(multiset1, multiset2); // returns false
multiset2.removeOccurrences(multiset1); // multiset2 现在包含3个&quot;a&quot;
multiset2.removeAll(multiset1);//multiset2移除所有&quot;a&quot;，虽然multiset1只有2个&quot;a&quot;
multiset2.isEmpty(); // returns true
</code></pre>
<h2 id="multisets中的其他工具方法还包括">Multisets中的其他工具方法还包括：</h2>
<table>
<tbody>
<tr class="odd">
<td>copyHighestCountFirst(Multiset)</td>
<td>返回Multiset的不可变拷贝，并将元素按重复出现的次数做降序排列</td>
</tr>
<tr class="even">
<td>unmodifiableMultiset(Multiset)</td>
<td>返回Multiset的只读视图</td>
</tr>
<tr class="odd">
<td>unmodifiableSortedMultiset(SortedMultiset)</td>
<td>返回SortedMultiset的只读视图</td>
</tr>
</tbody>
</table>
<pre class="example"><code>Multiset&lt;String&gt; multiset = HashMultiset.create();
multiset.add(&quot;a&quot;, 3);
multiset.add(&quot;b&quot;, 5);
multiset.add(&quot;c&quot;, 1);
ImmutableMultiset highestCountFirst = Multisets.copyHighestCountFirst(multiset);
//highestCountFirst，包括它的entrySet和elementSet，按{&quot;b&quot;, &quot;a&quot;, &quot;c&quot;}排列元素
</code></pre>
<h1 id="multimaps">Multimaps</h1>
<p>Multimaps提供了若干值得单独说明的通用工具方法</p>
<h2 id="index">index</h2>
<p>作为Maps.uniqueIndex的兄弟方法，Multimaps.index(Iterable, Function)通常针对的场 景是：有一组对象，它们有共同的特定属性，我们希望按照这个属性的值查询对象，但属性 值不一定是独一无二的。</p>
<p>比方说，我们想把字符串按长度分组。</p>
<pre class="example"><code>ImmutableSet digits = ImmutableSet.of(&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;);
Function&lt;String, Integer&gt; lengthFunction = new Function&lt;String, Integer&gt;() {
    public Integer apply(String string) {
        return string.length();
    }
};
ImmutableListMultimap&lt;Integer, String&gt; digitsByLength= Multimaps.index(digits, lengthFunction);
/*
 *  digitsByLength maps:
 *  3 =&gt; {&quot;one&quot;, &quot;two&quot;, &quot;six&quot;}
 *  4 =&gt; {&quot;zero&quot;, &quot;four&quot;, &quot;five&quot;, &quot;nine&quot;}
 *  5 =&gt; {&quot;three&quot;, &quot;seven&quot;, &quot;eight&quot;}
 */
</code></pre>
<h2 id="invertfrom">invertFrom</h2>
<p>鉴于Multimap可以把多个键映射到同一个值（译者注：实际上这是任何map都有的特性）， 也可以把一个键映射到多个值，反转Multimap也会很有用。Guava 提供了 invertFrom(Multimap toInvert, Multimap dest)做这个操作，并且你可以自由选择反转后 的Multimap实现。</p>
<p>注：如果你使用的是ImmutableMultimap，考虑改用ImmutableMultimap.inverse()做反转。</p>
<pre class="example"><code>ArrayListMultimap&lt;String, Integer&gt; multimap = ArrayListMultimap.create();
multimap.putAll(&quot;b&quot;, Ints.asList(2, 4, 6));
multimap.putAll(&quot;a&quot;, Ints.asList(4, 2, 1));
multimap.putAll(&quot;c&quot;, Ints.asList(2, 5, 3));
TreeMultimap&lt;Integer, String&gt; inverse = Multimaps.invertFrom(multimap, TreeMultimap&lt;String, Integer&gt;.create());
//注意我们选择的实现，因为选了TreeMultimap，得到的反转结果是有序的
/*
 * inverse maps:
 *  1 =&gt; {&quot;a&quot;}
 *  2 =&gt; {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}
 *  3 =&gt; {&quot;c&quot;}
 *  4 =&gt; {&quot;a&quot;, &quot;b&quot;}
 *  5 =&gt; {&quot;c&quot;}
 *  6 =&gt; {&quot;b&quot;}
 */
</code></pre>
<h2 id="formap">forMap</h2>
<p>想在Map对象上使用Multimap的方法吗？forMap(Map)把Map包装成SetMultimap。这个方法特 别有用，例如，与Multimaps.invertFrom结合使用，可以把多对一的Map反转为一对多的 Multimap。</p>
<pre class="example"><code>Map&lt;String, Integer&gt; map = ImmutableMap.of(&quot;a&quot;, 1, &quot;b&quot;, 1, &quot;c&quot;, 2);
SetMultimap&lt;String, Integer&gt; multimap = Multimaps.forMap(map);
// multimap：[&quot;a&quot; =&gt; {1}, &quot;b&quot; =&gt; {1}, &quot;c&quot; =&gt; {2}]
Multimap&lt;Integer, String&gt; inverse = Multimaps.invertFrom(multimap, HashMultimap&lt;Integer, String&gt;.create());
// inverse：[1 =&gt; {&quot;a&quot;,&quot;b&quot;}, 2 =&gt; {&quot;c&quot;}]
</code></pre>
<h2 id="包装器">包装器</h2>
<p>Multimaps提供了传统的包装方法，以及让你选择Map和Collection类型以自定义Multimap实 现的工具方法。</p>
<table>
<tbody>
<tr class="odd">
<td>只读包装</td>
<td>Multimap</td>
<td>ListMultimap</td>
<td>SetMultimap</td>
<td>SortedSetMultimap</td>
</tr>
<tr class="even">
<td>同步包装</td>
<td>Multimap</td>
<td>ListMultimap</td>
<td>SetMultimap</td>
<td>SortedSetMultimap</td>
</tr>
<tr class="odd">
<td>自定义实现</td>
<td>Multimap</td>
<td>ListMultimap</td>
<td>SetMultimap</td>
<td>SortedSetMultimap</td>
</tr>
</tbody>
</table>
<p>自定义Multimap的方法允许你指定Multimap中的特定实现。但要注意的是：</p>
<ul>
<li>Multimap假设对Map和Supplier产生的集合对象有完全所有权。这些自定义对象应避免手 动更新，并且在提供给Multimap时应该是空的，此外还不应该使用软引用、弱引用或虚引 用。</li>
<li>无法保证修改了Multimap以后，底层Map的内容是什么样的。</li>
<li>即使Map和Supplier产生的集合都是线程安全的，它们组成的Multimap也不能保证并发操 作的线程安全性。并发读操作是工作正常的，但需要保证并发读写的话，请考虑用同步包 装器解决。</li>
<li>只有当Map、Supplier、Supplier产生的集合对象、以及Multimap存放的键值类型都是可 序列化的，Multimap才是可序列化的。</li>
<li>Multimap.get(key)返回的集合对象和Supplier返回的集合对象并不是同一类型。但如果 Supplier返回的是随机访问集合，那么Multimap.get(key)返回的集合也是可随机访问的。</li>
</ul>
<p>请注意，用来自定义Multimap的方法需要一个Supplier参数，以创建崭新的集合。下面有个 实现ListMultimap的例子——用TreeMap做映射，而每个键对应的多个值用LinkedList存储。</p>
<pre class="example"><code>ListMultimap&lt;String, Integer&gt; myMultimap = Multimaps.newListMultimap(
    Maps.&lt;String, Collection&gt;newTreeMap(),
    new Supplier&lt;LinkedList&gt;() {
        public LinkedList get() {
            return Lists.newLinkedList();
        }
    });

</code></pre>
<h1 id="tables">Tables</h1>
<p>Tables类提供了若干称手的工具方法。</p>
<h2 id="自定义table">自定义Table</h2>
<p>堪比Multimaps.newXXXMultimap(Map, Supplier)工具方法，Tables.newCustomTable(Map, Supplier&lt;Map&gt;)允许你指定Table用什么样的map实现行和列。</p>
<pre class="example"><code>// 使用LinkedHashMaps替代HashMaps
Table&lt;String, Character, Integer&gt; table = Tables.newCustomTable(
    Maps.&lt;String, Map&lt;Character, Integer&gt;&gt;newLinkedHashMap(),
       new Supplier&lt;Map&lt;Character, Integer&gt;&gt; () {
         public Map&lt;Character, Integer&gt; get() {
           return Maps.newLinkedHashMap();
         }
       });
</code></pre>
<h2 id="transpose">transpose</h2>
<p>transpose(Table&lt;R, C, V&gt;)方法允许你把Table&lt;C, R, V&gt;转置成Table&lt;R, C, V&gt;。例如， 如果你在用Table构建加权有向图，这个方法就可以把有向图反转。</p>
<h2 id="包装器-1">包装器</h2>
<p>还有很多你熟悉和喜欢的Table包装类。然而，在大多数情况下还请使用ImmutableTable</p>

    </div>
</div>
<div id="postamble" class="status">
    <div id="archive" style="padding-top: 3em; padding-bottom: 2em;">
        <a href="https://bruceasu.github.io/archive.html">其它文章</a>
    </div>
</div>
<script src="https://bruceasu.github.io/js/av-min-1.5.0.js"></script>
<script type="application/javascript">
    var BlogDirectory = {
        /*
            获取元素位置，距浏览器左边界的距离（left）和距浏览器上边界的距离（top）
        */
        getElementPosition: function (ele) {
            var topPosition = 0;
            var leftPosition = 0;
            while (ele) {
                topPosition += ele.offsetTop;
                leftPosition += ele.offsetLeft;
                ele = ele.offsetParent;
            }
            return {top: topPosition, left: leftPosition};
        },

        /*
        获取滚动条当前位置
        */
        getScrollBarPosition: function () {
            var scrollBarPosition = document.body.scrollTop || document.documentElement.scrollTop;
            return scrollBarPosition;
        },

        /*
        移动滚动条，finalPos 为目的位置，internal 为移动速度
        */
        moveScrollBar: function (finalpos, interval) {

            //若不支持此方法，则退出
            if (!window.scrollTo) {
                return false;
            }

            //窗体滚动时，禁用鼠标滚轮
            window.onmousewheel = function () {
                return false;
            };

            //清除计时
            if (document.body.movement) {
                clearTimeout(document.body.movement);
            }

            var currentpos = BlogDirectory.getScrollBarPosition();//获取滚动条当前位置

            var dist = 0;
            if (currentpos == finalpos) {//到达预定位置，则解禁鼠标滚轮，并退出
                window.onmousewheel = function () {
                    return true;
                }
                return true;
            }
            if (currentpos < finalpos) {//未到达，则计算下一步所要移动的距离
                dist = Math.ceil((finalpos - currentpos) / 10);
                currentpos += dist;
            }
            if (currentpos > finalpos) {
                dist = Math.ceil((currentpos - finalpos) / 10);
                currentpos -= dist;
            }

            var scrTop = BlogDirectory.getScrollBarPosition();//获取滚动条当前位置
            window.scrollTo(0, currentpos);//移动窗口
            if (BlogDirectory.getScrollBarPosition() == scrTop)//若已到底部，则解禁鼠标滚轮，并退出
            {
                window.onmousewheel = function () {
                    return true;
                }
                return true;
            }

            //进行下一步移动
            var repeat = "BlogDirectory.moveScrollBar(" + finalpos + "," + interval + ")";
            document.body.movement = setTimeout(repeat, interval);
        },

        htmlDecode: function (text) {
            var temp = document.createElement("div");
            temp.innerHTML = text;
            var output = temp.innerText || temp.textContent;
            temp = null;
            return output;
        },

        /*
        创建博客目录，
        id表示包含博文正文的 div 容器的 id，
        mt 和 st 分别表示主标题和次级标题的标签名称（如 H2、H3，大写或小写都可以！），
        interval 表示移动的速度
        */
        createBlogDirectory: function (id, mt, st, interval) {
            //获取博文正文div容器
            var elem = document.getElementById(id);
            if (!elem) {
                return false;
            }
            //获取div中所有元素结点
            var nodes = elem.getElementsByTagName("*");
            //创建博客目录的div容器
            var divSideBar = document.createElement('DIV');
            divSideBar.className = 'sideBar';
            divSideBar.setAttribute('id', 'sideBar');
            var divSideBarTab = document.createElement('DIV');
            divSideBarTab.setAttribute('id', 'sideBarTab');
            divSideBar.appendChild(divSideBarTab);
            var h2 = document.createElement('H2');
            divSideBarTab.appendChild(h2);
            var txt = document.createTextNode('目录导航');
            h2.appendChild(txt);
            var divSideBarContents = document.createElement('DIV');
            divSideBarContents.style.display = 'none';
            divSideBarContents.setAttribute('id', 'sideBarContents');
            divSideBar.appendChild(divSideBarContents);
            //创建自定义列表
            var dlist = document.createElement("ul");
            divSideBarContents.appendChild(dlist);
            var num = 0;//统计找到的mt和st
            mt = mt.toUpperCase();//转化成大写
            st = st.toUpperCase();//转化成大写
            var lastTagName = "h1";
            var currentList = dlist;
            var lastList = dlist;

            //遍历所有元素结点
            var p = /h\d/i
            for (var i = 0; i < nodes.length; i++) {
                //if(nodes[i].nodeName == mt|| nodes[i].nodeName == st)
                console.log("test " + nodes[i].nodeName, p.test(nodes[i].nodeName))
                if (p.test(nodes[i].nodeName)) {
                    //获取标题文本
                    var nodetext = nodes[i].innerHTML.replace(/<\/?[^>]+>/g, "");//innerHTML里面的内容可能有HTML标签，所以用正则表达式去除HTML的标签
                    nodetext = nodetext.replace(/ /ig, "");//替换掉所有的 
                    nodetext = BlogDirectory.htmlDecode(nodetext);
                    //插入锚
                    nodes[i].setAttribute("id", "blogTitle" + num);
                    var item;
                    if (nodes[i].nodeName > lastTagName) {
                        // open new
                        lastList = currentList;
                        currentList = document.createElement("ul");
                        lastList.appendChild(currentList);
                        lastTagName = nodes[i].nodeName
                    } else if (nodes[i].nodeName < lastTagName) {
                        // close
                        currentList = lastList;
                        lastTagName = nodes[i].nodeName
                    } else {

                    }
                    item = document.createElement("li");
                    //创建锚链接
                    var itemtext = document.createTextNode(nodetext);
                    item.appendChild(itemtext);
                    item.setAttribute("name", num);
                    item.onclick = function () {        //添加鼠标点击触发函数
                        var pos = BlogDirectory.getElementPosition(
                            document.getElementById("blogTitle" + this.getAttribute("name")));
                        if (!BlogDirectory.moveScrollBar(pos.top, interval)) {
                            return false;
                        }
                    };

                    //将自定义表项加入自定义列表中
                    //dlist.appendChild(item);
                    currentList.appendChild(item);
                    num++;
                }
            }

            if (num == 0) {
                return false;
            }
            /*鼠标进入时的事件处理*/
            divSideBarTab.onmouseenter = function () {
                divSideBarContents.style.display = 'block';
            }
            /*鼠标离开时的事件处理*/
            divSideBar.onmouseleave = function () {
                divSideBarContents.style.display = 'none';
            }

            document.body.appendChild(divSideBar);
        }

    };

    window.onload = function () {
        BlogDirectory.createBlogDirectory("content", "h1", "h2", 20);
    }
</script>
</body>
</html>
